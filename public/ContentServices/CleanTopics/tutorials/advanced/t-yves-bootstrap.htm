<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Yves and Zed are both built upon the Silex micro-framework . So most concepts about modern web frameworks apply here as well. Instatic/public/Yves/index.phpyou will find the entry for the front-end application. &lt;?php
$errorHandlerEnvironment = new ErrorHandlerEnvironment();
$errorHandlerEnvironment-&gt;initialize(); $bootstrap = new YvesBootstrap();
$bootstrap -&gt;boot() -&gt;run(); Theboot()method returns a Silex application which has a run() method, that processes the request and returns a response to the browser.YvesBootstrapis responsible for registering all the used service providers, controller providers and routers. The registration process is handled by theboot()operation. Click to expand the code sample &lt;?php
namespace Pyz\Yves\Application; use Spryker\Shared\Application\Communication\Application; class YvesBootstrap
{ /** * @var Application */ protected $application; public function __construct() { $this-&gt;application = new Application(); } /** * @return Application */ public function boot() { $this-&gt;registerServiceProviders(); $this-&gt;registerRouters(); $this-&gt;registerControllerProviders(); return $this-&gt;application; } // ...
} Service Providers We are using the Silex way to register service providers. You can easily register new service providers in YvesBootstrap. Note that the order of the registration matters, since sometimes one service provider already needs another service to be registered already. &lt;?php
// ... /** * @return void */
protected function registerServiceProviders()
{ $this-&gt;application-&gt;register(new ServiceProvider1()); $this-&gt;application-&gt;register(new ServiceProvider2()); // ...
} // ... Service providers need to implement\Silex\ServiceProviderInterface. You can find detailed information about service providers in the official Silex documentation page . Controller Providers Whenever you need to create a new controller you’ll need to define a path where it’s available. To do that you’ll need to register your controllers for a specific path (or in other words to create new route definition) in a controller provider. Let’s have a look at theApplicationControllerProviderand how it registers two controllers in the Application(Undefined variable: General.bundle/module). &lt;?php
namespace Pyz\Yves\Application\Plugin\Provider; use Pyz\Yves\Application\Plugin\Provider\AbstractYvesControllerProvider;
use Silex\Application; class ApplicationControllerProvider extends AbstractYvesControllerProvider
{ const ROUTE_HOME = 'home'; const ROUTE_IMPRINT = 'imprint'; /** * @return void */ protected function defineControllers(Application $app) { $this-&gt;createGetController('/', static::ROUTE_HOME, 'Application', 'Index'); $this-&gt;createGetController('/imprint', static::ROUTE_IMPRINT, 'Application', 'Static', 'imprint'); }
} Here we connect the IndexController and StaticController in the Application(Undefined variable: General.bundle/module)to the paths/and/imprint. The last argument is the action name, which defaults to index. Note that we are extendingAbstractYvesControllerProviderin the example which helps to get the URL prefix in the mounting process, but this is optional to use. If you want to register your controller providers the Silex way, you only need to implement\Silex\ControllerProviderInterfacefor your class and mount your controller providers as Silex recommends. The mounting process happens inYvesBootstrap. The example assumes that the Controller providers we use extends theAbstractYvesControllerProvider. &lt;?php
/** * @return void */
protected function registerControllerProviders()
{ $controllerProviders = [ new ApplicationControllerProvider(), new CheckoutControllerProvider(), // ... ]; foreach ($controllerProviders as $controllerProvider) { $this-&gt;application-&gt;mount($controllerProvider-&gt;getUrlPrefix(), $controllerProvider); }
} Routers Routers are responsible to find a matching controller action for each request. Spryker use Symfony’s ChainRouter to chain multiple routers which means each router will be executed after each other and the first which finds a matching path will resolve the request. By default we provide three routers: The first router is theStorageRouterwhich tries to match the path with the key-value storage (Redis). The next is theSearchRouterwhich tries to match the path with Elasticsearch (e.g. free text search pages) The last is the defaultSilexRouterwhich tries to match the path with the registered ControllerProviders. If you want to add a new router, you can add it in YvesBootsrap, but make sure you do it in the right ordering. &lt;?php
/** * @return void */
protected function registerRouters()
{ $this-&gt;application-&gt;addRouter((new StorageRouter())-&gt;setSsl(false)); $this-&gt;application-&gt;addRouter((new SearchRouter())-&gt;setSsl(false)); $this-&gt;application-&gt;addRouter(new SilexRouter($this-&gt;application));
}</body>
</html>