<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Upgrading from Version 7.* to Version 8.* In Sales module version 8 we have added multi-currency support, this release added two new fields to spy_sales table to persist "currency" and "store". Also Order saver now stores currency and store where order is placed. Run the following SQL request: ALTER TABLE "spy_sales_order" ADD "store" VARCHAR(255), ADD "currency_iso_code" VARCHAR(5); CREATE INDEX "spy_sales_order-store" ON "spy_sales_order" ("store"); CREATE INDEX "spy_sales_order-currency_iso_code" ON "spy_sales_order" ("currency_iso_code"); Runpropel:model:buildto generate new propel model classes. Upgrading from Version 6.* to Version 7.* In Sales version 7, a new table for sales order item metadata (spy_sales_order_item_metadata) has been added. In order to migrate, the following table should be added: BEGIN; CREATE SEQUENCE "spy_sales_order_item_metadata_pk_seq"; CREATE TABLE "spy_sales_order_item_metadata"
( "id_sales_order_item_metadata" INTEGER NOT NULL, "fk_sales_order_item" INTEGER NOT NULL, "super_attributes" TEXT NOT NULL, "image" TEXT, "created_at" TIMESTAMP, "updated_at" TIMESTAMP, PRIMARY KEY ("id_sales_order_item_metadata")
); ALTER TABLE "spy_sales_order_item_metadata" ADD CONSTRAINT "spy_sales_order_item_metadata-fk_sales_order_item" FOREIGN KEY ("fk_sales_order_item") REFERENCES "spy_sales_order_item" ("id_sales_order_item"); COMMIT; Also, it should be ensured that each order item has such meta data records. To insert them, use: INSERT INTO spy_sales_order_item_metadata (id_sales_order_item_metadata, fk_sales_order_item, super_attributes, created_at, updated_at) SELECT nextval('spy_sales_order_item_metadata_pk_seq'), id_sales_order_item, '[]', now(), now() FROM spy_sales_order_item; For MySQL, you can omit the ID to rely on auto incrementation: INSERT INTO spy_sales_order_item_metadata (fk_sales_order_item, super_attributes, created_at, updated_at) SELECT id_sales_order_item, '[]', now(), now() FROM spy_sales_order_item; Upgrading from Version 5.* to Version 6.* There are two steps for migrating to version 6 and they should be performed in the following order: Step 1: Migratingsales_order.fk_customer,sales_order.fk_shipment_methodandsales_order.shipment_delivery_timerelated data, to the new structure. Do not run any propel commands when executing this, it will drop foreign keys without giving you chance to migrate data. We created a new module into which all deprecated code was moved. We also changed the sales schema, so if you include the new bundle, fields will stay. Include the following into yourcomposer.json: "spryker/calculation-migration": "dev-master". Run composer update. As of Sales module version 6, all foreign keys to customer and shipment were removed, so that Sales related tables won't have hard relations to other concepts like shipment and customer. This separation allows having services based on bound contexts. As a result,fk_customeris replaced bycustomer_refecence, a unique customer id generated by the Spryker number generator. Thefk_shipment_methodforeign key has been replaced with thespy_sales_shipmenttable which stores all shipment related data. Create new DB columns to migrate the data to, run SQL: BEGIN; CREATE SEQUENCE "spy_sales_shipment_pk_seq"; CREATE TABLE "spy_sales_shipment" ( "id_sales_shipment" INTEGER NOT NULL, "fk_sales_order" INTEGER NOT NULL, "fk_sales_expense" INTEGER, "name" VARCHAR(255), "delivery_time" VARCHAR(255), "carrier_name" VARCHAR(255), "created_at" TIMESTAMP, "updated_at" TIMESTAMP, PRIMARY KEY ("id_sales_shipment") ); ALTER TABLE "spy_sales_shipment" ADD CONSTRAINT "spy_sales_shipment-fk_sales_expense" FOREIGN KEY ("fk_sales_expense") REFERENCES "spy_sales_expense" ("id_sales_expense"); ALTER TABLE "spy_sales_shipment" ADD CONSTRAINT "spy_sales_shipment-fk_sales_order" FOREIGN KEY ("fk_sales_order") REFERENCES "spy_sales_order" ("id_sales_order"); ALTER TABLE "spy_sales_order" ADD "customer_reference" VARCHAR(255); CREATE INDEX "spy_sales_order-customer_reference" ON "spy_sales_order" ("customer_reference"); COMMIT; Now that the required fields/tables have been created, migrate your data using the following script: Migration Guide - Sales . This command will migrate: allsales_order.fk_customerdata tosales_order.customer_reference allsales_order.fk_shipment_methodtospy_sales_shipment table. Place the console command invoked byvendor/bin/consoleinto your Sales module under\Pyz\Zed\Sales\Communication\Console\ShipmentAndCustomerMigrationConsole.php. Register the console command at\Pyz\Zed\Console\ConsoleDependencyProvider::getConsoleCommands. Run it likevendor/bin/console sales:migrate Verification step: It is important to see if the data migration went well. To check, look at the tables:spy_sales_shipmentandspy_sales.customer_reference. If they are populated, you can drop the old foreign keys. To drop the old foreign keys: BEGIN; ALTER TABLE "spy_sales_order" DROP CONSTRAINT "spy_sales_order-fk_customer"; ALTER TABLE "spy_sales_order" DROP COLUMN "fk_customer"; ALTER TABLE "spy_sales_order" DROP CONSTRAINT "spy_sales_order-fk_shipment_method"; ALTER TABLE "spy_sales_order" DROP COLUMN "fk_shipment_method"; ALTER TABLE "spy_sales_order" DROP COLUMN "shipment_delivery_time"; COMMIT; Now that orders are migrated, run Propel migrations to update Sales related entities and relations:vendor/bin/console propel:diff,vendor/bin/console propel:model:build. +Run transfers update:vendor/bin/console transfer:generate. Step 2: Migrating the calculated data and moving from thesales-aggregatorconcept requires adding the calculated fields to the sales tables. Now you have two options: keep old calculators (deprecated) or migrate to the new calculators logic. To keep old calculation logic see Migration Guide - Calculation . To migrate to the new structure see Migrating Sales to the New Calculator Logic . Upgrading from Version 3.* to Version 4.* With the Product-Bundle module release, the Sales schema file spy_sales.schema.xml was changed. Product-Bundle related entries were removed and moved toSpryker/Zed/ProductBundle/Persistence/Propel/Schema/spy_sales.schema.xml. As this feature was not used in core/demoshop, we also changed the data structure. Unique Product Quantity field in sales detail page is calculated differently now. Data comes fromOrderTransfer::uniqueProductQuantity. Please update your templates if overwritten. Sales Migration Console Command &lt;?php
/** * Copyright © 2017-present Spryker Systems GmbH. All rights reserved. * Use of this software requires acceptance of the Evaluation License Agreement. See LICENSE file. */ namespace Pyz\Zed\Sales\Communication\Console; use Exception;
use Orm\Zed\Customer\Persistence\SpyCustomerQuery;
use Orm\Zed\Sales\Persistence\SpySalesOrderQuery;
use Orm\Zed\Shipment\Persistence\SpyShipmentMethodQuery;
use PDO;
use Propel\Runtime\Exception\PropelException;
use Propel\Runtime\Propel;
use Spryker\Shared\Shipment\ShipmentConstants;
use Spryker\Zed\Kernel\Communication\Console\Console;
use Spryker\Zed\Tax\Communication\Plugin\Calculator\TaxAmountAfterCancellationCalculatorPlugin;
use Spryker\Zed\Tax\Communication\Plugin\Calculator\TaxAmountCalculatorPlugin;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Propel\Runtime\ActiveQuery\Criteria;
use Symfony\Component\Console\Question\ConfirmationQuestion; /** * @method \Spryker\Zed\Sales\Communication\SalesCommunicationFactory getFactory() * @method \Spryker\Zed\Sales\Business\SalesFacade getFacade() */
class ShipmentAndCustomerMigrationConsole extends Console
{ const COMMAND_NAME = 'sales:migrate'; const COMMAND_DESCRIPTION = 'Migrate sales shipment and customer data to new data structure'; /** * @return void */ protected function configure() { $this-&gt;setName(static::COMMAND_NAME); $this-&gt;setDescription(static::COMMAND_DESCRIPTION); parent::configure(); } /** * @param \Symfony\Component\Console\Input\InputInterface $input * @param \Symfony\Component\Console\Output\OutputInterface $output * * @return int|null|void */ protected function execute(InputInterface $input, OutputInterface $output) { $exportOrdersTillGivenDate = new \DateTime(); $ordersForUpdate = SpySalesOrderQuery::create() -&gt;filterByCreatedAt( $exportOrdersTillGivenDate, Criteria::LESS_EQUAL ) -&gt;find(); $totalNumberOfOrdersForUpdate = count($ordersForUpdate); if ($totalNumberOfOrdersForUpdate === 0) { $output-&gt;writeln( sprintf( 'No orders found for given date range &lt;= %s ', $exportOrdersTillGivenDate-&gt;format('Y-m-d') ) ); return; } $helper = $this-&gt;getQuestionHelper(); $question = new ConfirmationQuestion( sprintf('Migrate %s orders? (y|n)', $totalNumberOfOrdersForUpdate), false ); if (!$helper-&gt;ask($input, $output, $question)) { $output-&gt;writeln('Aborted.'); return; } $output-&gt;writeln(sprintf('Processing %s orders...', $totalNumberOfOrdersForUpdate)); $numberOfOrdersUpdated = 0; $connection = Propel::getConnection(); foreach ($ordersForUpdate as $salesOrderEntity) { $idShipmentMethod = $salesOrderEntity-&gt;getFkShipmentMethod(); $shipmentMethodEntity = SpyShipmentMethodQuery::create() -&gt;filterByIdShipmentMethod($idShipmentMethod) -&gt;findOne(); try { $connection-&gt;beginTransaction(); if (!$shipmentMethodEntity) { $output-&gt;writeln( sprintf( 'Shipment method with id %d for order %d not found', $salesOrderEntity-&gt;getFkShipmentMethod(), $salesOrderEntity-&gt;getIdSalesOrder()) ); continue; } else { $idSalesExpense = $this-&gt;findIdSalesExpense($salesOrderEntity); try { $dataFetcher = $connection-&gt;query("SELECT nextval('spy_sales_shipment_pk_seq')"); $idSalesShipment = $dataFetcher-&gt;fetchColumn(); } catch (Exception $e) { throw new PropelException('Unable to get sequence id.', 0, $e); } $modifiedColumns = []; $modifiedColumns[':p0'] = 'carrier_name'; $modifiedColumns[':p1'] = 'name'; $modifiedColumns[':p2'] = 'delivery_time'; $modifiedColumns[':p3'] = 'fk_sales_order'; $modifiedColumns[':p4'] = 'fk_sales_expense'; $modifiedColumns[':p5'] = 'id_sales_shipment'; $modifiedColumns[':p6'] = 'created_at'; $modifiedColumns[':p7'] = 'updated_at'; $sql = sprintf( 'INSERT INTO spy_sales_shipment (%s) VALUES (%s)', implode(', ', $modifiedColumns), implode(', ', array_keys($modifiedColumns)) ); $dateTime = (new \DateTime())-&gt;format('Y-m-d H:i:s'); $stmt = $connection-&gt;prepare($sql); $stmt-&gt;bindValue(':p0', $shipmentMethodEntity-&gt;getShipmentCarrier()-&gt;getName(), PDO::PARAM_STR); $stmt-&gt;bindValue(':p1', $shipmentMethodEntity-&gt;getName(), PDO::PARAM_STR); $stmt-&gt;bindValue(':p2', $salesOrderEntity-&gt;getShipmentDeliveryTime(), PDO::PARAM_STR); $stmt-&gt;bindValue(':p3', $salesOrderEntity-&gt;getIdSalesOrder(), PDO::PARAM_INT); $stmt-&gt;bindValue(':p4', $idSalesExpense, PDO::PARAM_INT); $stmt-&gt;bindValue(':p5', $idSalesShipment, PDO::PARAM_INT); $stmt-&gt;bindValue(':p6', $dateTime, PDO::PARAM_STR); $stmt-&gt;bindValue(':p7', $dateTime, PDO::PARAM_STR); $stmt-&gt;execute(); } $customerEntity = $salesOrderEntity-&gt;getCustomer(); if ($customerEntity) { $stmt = $connection-&gt;prepare( 'UPDATE spy_sales_order SET customer_reference = :customerReference WHERE id_sales_order = :idSalesOrder' ); $customerReference = $customerEntity-&gt;getCustomerReference(); $idSalesOrder = $salesOrderEntity-&gt;getIdSalesOrder(); $stmt-&gt;bindParam(':customerReference', $customerReference, PDO::PARAM_STR); $stmt-&gt;bindParam(':idSalesOrder', $idSalesOrder, PDO::PARAM_INT); $stmt-&gt;execute(); } $numberOfOrdersUpdated++; $connection-&gt;commit(); } catch (Exception $exception) { $output-&gt;writeln($exception-&gt;getMessage() . $exception-&gt;getTraceAsString()); $connection-&gt;rollBack(); } } $output-&gt;writeln( sprintf( 'Migration complete. %s orders migrated.', $numberOfOrdersUpdated ) ); } /** * @return mixed */ protected function getQuestionHelper() { return $this-&gt;getHelper('question'); } /** * @param $salesOrderEntity * * @return null */ protected function findIdSalesExpense($salesOrderEntity) { $idSalesExpense = null; foreach ($salesOrderEntity-&gt;getExpenses() as $expenseEntity) { if (ShipmentConstants::SHIPMENT_EXPENSE_TYPE !== $expenseEntity-&gt;getType()) { continue; } $idSalesExpense = $expenseEntity-&gt;getIdSalesExpense(); } return $idSalesExpense; } } ?&gt; See also: Learn more about Sales Module Last review date: Sep. 14, 2017</body>
</html>