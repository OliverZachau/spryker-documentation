<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>The latest version of this(Undefined variable: General.bundle/module)can be found in Search section One of the most important features in an e-commerce application is to give the customer the ability to find the specific products. Depending on how easy it is to find the products the customer is searching for and how relevant the search results are, the search feature is a crucial aspect for an e-commerce business. Spryker provides a fully functional solution to integrateElasticsearchas a search engine. You can extend this solution or customize it to fit for your needs. Spryker uses Elasticsearch version 2.x. We’ll have a look on how to configure and use theSearch (Undefined variable: General.bundle/module): Configure Elasticsearch Search Collector Configuration Search Query Configure Search Features Previous Versions Search - version 3.0 Configure Elasticsearch Elasticsearch is aNoSQLdata store which allows us to predefine the structure of the data we’ll be storing in it. Since the data structure we use is static, we would like to define it in advance. The definitions of the indexes and mapping types are written inJSONformat, just as you’ll find it in theElasticsearchdocumentation. The content of the configuration files needs to follow the conventions of the official Elasticsearch index creation documentation. Note that the current search installer support only settings and mappings but if you need more, feel free to extend it on the project level. Default Schema You can find the default schema configuration file atvendor/spryker/search/src/Spryker/Shared/Search/IndexMap/search.json. Tip If you want to disable the installation of the default mapping, you need to override the core configuration defined inSpryker\Zed\Search\SearchConfig::getJsonIndexDefinitionDirectories()by implementing it on the project level (e.g.Pyz\Zed\Search\SearchConfig). Each configured store will have its own index installed automatically. The name of the indexes are composed from store name + underscore + configuration file name (e.g.:de_search). Defining New Indexes and Mapping Types You can define new indexes and mapping types by creating new configuration files under theSharednamespace of any(Undefined variable: General.bundle/module). Example: src/Shared/MyBundleName/IndexMap/myindex.json You are able to extend or overwrite existing configurations by creating a new file with the same name you wish to modify and provide only the differences compared to the original one. When the search installer runs, it will first read all the available configuration files and merge them by index name per each store. This might be handy if you have bundles which are not tightly coupled together but both need to use the same index for some reason or you just need to extend or override the default configuration provided on the Core level. It’s also possible to extend or modify indexes and mapping types for specific stores. All you need to do is to create a new configuration file along with the name of the store (e.g.de_search.json) and it will be only used for that store. For example, you might have a different analysing strategy for your stores, so you’ll need to define it separately. Installing Indexes and Mapping Types Execute the following command to run the installation process: vendor/bin/console setup:search This will install indexes which are not yet created and update the mapping types based on theJSONconfigurations. Note that if an index is created with the given settings, it won’t be changed by running this process, but the mapping can be modified and will be changed. In development environment, if you need to create new analysers or change the index settings, you need to delete the index first and run the install process again. When you run the search installer for every mapping type, a helper class will be auto-generated. You can find these classes under the\Generated\Search\IndexMapnamespace. The name of the generated class starts with the name of the mapping type and is suffixed withIndexMap. For the default page mapping type, the class is\Generated\Search\IndexMap\PageIndexMap. These classes provide some information from the mapping type, such as the fields and the metadata. Use these classes for references when you need to program against something related to the schema of that mapping type. If you change a mapping type and run the installer, the auto-generated classes will also change accordingly. Search Collector Configuration In this section you’ll learn how to easily map collected data from the database to the default Elasticsearch page mapping type. If you need information about how collectors work in general, you can read more about it on theCollectordocumentation page. First, you need to implement\Spryker\Zed\Search\Dependency\Plugin\PageMapInterfaceinterface as a plugin. This interface contains thebuildPageMap()method which will be called for each collected document and its responsibility is to create aPageMapTransferobject and fill it with the mapped data. Basically, this transfer object represents one document in the page type. ThebuildPageMap()method provides an instance of\Spryker\Zed\Search\Business\Model\Elasticsearch\DataMapper\PageMapBuilderInterfaceto help to fill this transfer object with the correct data in the correct format. It’s really easy to use, all you need to do is to tell the PageMapBuilder which data you need to have in the search result data, which data you want to filter by, which data you want to sort by, etc. Click to expand the code sample &lt;?php /** * @param \Spryker\Zed\Search\Business\Model\Elasticsearch\DataMapper\PageMapBuilderInterface $pageMapBuilder * @param array $productData * @param \Generated\Shared\Transfer\LocaleTransfer $locale * * @return \Generated\Shared\Transfer\PageMapTransfer */ public function buildPageMap(PageMapBuilderInterface $pageMapBuilder, array $productData, LocaleTransfer $locale) { $pageMapTransfer = (new PageMapTransfer()) -&gt;setStore(Store::getInstance()-&gt;getStoreName()) -&gt;setLocale($locale-&gt;getLocaleName()); $price = $this-&gt;getPriceBySku($productData['abstract_sku']); $pageMapBuilder -&gt;addSearchResultData($pageMapTransfer, 'id_product_abstract', $productData['id_product_abstract']) -&gt;addSearchResultData($pageMapTransfer, 'abstract_sku', $productData['abstract_sku']) -&gt;addSearchResultData($pageMapTransfer, 'abstract_name', $productData['abstract_name']) -&gt;addSearchResultData($pageMapTransfer, 'price', $price) -&gt;addSearchResultData($pageMapTransfer, 'url', $this-&gt;getProductUrl($productData)) -&gt;addSearchResultData($pageMapTransfer, 'available', $this-&gt;isAvailable($productData) -&gt;addFullTextBoosted($pageMapTransfer, $productData['abstract_name']) -&gt;addSuggestionTerms($pageMapTransfer, $productData['abstract_name']) -&gt;addCompletionTerms($pageMapTransfer, $productData['abstract_name']) -&gt;addStringSort($pageMapTransfer, 'name', $productData['abstract_name']) -&gt;addIntegerSort($pageMapTransfer, 'price', $price) -&gt;addIntegerFacet($pageMapTransfer, 'price', $price) -&gt;addCategory($pageMapTransfer, $this-&gt;getAllParentCategories($productData), $this-&gt;getDirectParentCategories($productData)); return $pageMapTransfer; } In the example above, you can see that first we create thePageMapTransferinstance, add some metadata to it, then with the help of thePageMapBuilderInterfacewe can easily map some data to the transfer. At the end, we’ll get the data for a document similar to the example below: Click to expand the code sample { "store": "DE", "locale": "en_US", "search-result-data": { "id_product_abstract": 1, "abstract_sku": "foo", "abstract_name": "Lorem ipsum", "url": "/lorem-ipsum", "price": 1234, "available": true }, "full-text-boosted": [ "Lorem ipsum" ], "suggestion-terms": [ "Lorem ipsum" ], "completion-terms": [ "Lorem ipsum" ], "string-sort": { "name": "Lorem ipsum" }, "integer-sort": { "price": 1234 }, "integer-facet": [ { "facet-name": "price", "facet-value": 1234 } ], "category": { "direct-parents": [ "1" ], "all-parents": [ "1", "2", "3" ] }
} After implementing ourPageMapplugin we need to make sure that we also use it in our collector. The collector has thecollectItem()method which has the data for our PageMap plugin to generate thePageMapTransfer. ThecollectItem()by definition needs to return an array which is exactly the final data for one document pushed toElasticsearch. To transform the generatedPageMapTransferinto the final document in the right format, use thetransformPageMapToDocument()method of theSearchFacade. In the example below you can see how thePageMapplugin is used in theProductCollectorfrom Demoshop. Click to expand the code sample &lt;?php
namespace Pyz\Zed\Collector\Business\Search; use Spryker\Zed\Collector\Business\Collector\Search\AbstractSearchPdoCollector;
use Spryker\Zed\Search\Business\SearchFacadeInterface;
use Spryker\Zed\Search\Dependency\Plugin\PageMapInterface; class ProductCollector extends AbstractSearchPdoCollector
{ /** * @var \Spryker\Zed\Search\Dependency\Plugin\PageMapInterface */ protected $productDataPageMapPlugin; /** * @var \Spryker\Zed\Search\Business\SearchFacadeInterface */ protected $searchFacade; /** * @param \Spryker\Zed\Search\Dependency\Plugin\PageMapInterface $productDataPageMapPlugin * @param \Spryker\Zed\Search\Business\SearchFacadeInterface $searchFacade */ public function __construct(PageMapInterface $productDataPageMapPlugin, SearchFacadeInterface $searchFacade) { $this-&gt;productDataPageMapPlugin = $productDataPageMapPlugin; $this-&gt;searchFacade = $searchFacade; } /** * @param string $touchKey * @param array $collectItemData * * @return array */ protected function collectItem($touchKey, array $collectItemData) { return $this -&gt;searchFacade -&gt;transformPageMapToDocument($this-&gt;productDataPageMapPlugin, $collectItemData, $this-&gt;locale); } } Dynamic Product Attribute Mapping Product attributes can be changed in time, when for example a shop decides to add a few new types of products to the catalogue. As we saw earlier, it’s possible to configure which data you provide for Elasticsearch. It also can be applied for product attributes, but it’s not too effective that developers need to take care of them if they are changing a lot. For this reason, theProductSearch (Undefined variable: General.bundle/module)provides an extra feature that allows you to dynamically map product attributes to the documents for Elasticsearch page type. In the database there is aspy_product_search_attribute_maptable that contains two fields: fk_product_attributes_metadatawhich is the foreign key of the product attribute target_fieldwhich is a string, representing the field name from the Elasticsearch page type. If you feed this table with data (by building a UI in Zed, or in any other way) you can easily extend the previously implementedbuildPageMap()method by callingProductSearchFacade’s mapDynamicProductAttributes()at the end. So let’s extend our previous example ofbuildPageMap(). &lt;?php /** * @param \Spryker\Zed\Search\Business\Model\Elasticsearch\DataMapper\PageMapBuilderInterface $pageMapBuilder * @param array $productData * @param \Generated\Shared\Transfer\LocaleTransfer $locale * * @return \Generated\Shared\Transfer\PageMapTransfer */ public function buildPageMap(PageMapBuilderInterface $pageMapBuilder, array $productData, LocaleTransfer $locale) { // ... $pageMapTransfer = $this -&gt;productSearchFacade -&gt;mapDynamicProductAttributes($pageMapBuilder, $pageMapTransfer, $attributes); return $pageMapTransfer; } Zed UI for product attribute mapping It's in Spryker's pipeline to provide an easy to use Zed UI for product dynamic attribute mapping. Search Query Now we have all necessary data in Elasticsearch, it’s time to display them inYves. In order to achieve this, we first need to query Elasticsearch, which will return raw data for us that we need to process and prepare to display it in our templates. In theSearchClientyou can find thesearch()method (\Spryker\Client\Search\SearchClientInterface::search()). This is the method that you need to call to execute any search query. It expects to receive an instance of\Spryker\Client\Search\Dependency\Plugin\QueryInterfaceas first parameter, which represents the query itself, and a collection of\Spryker\Client\Search\Dependency\Plugin\ResultFormatterPluginInterfaceinstances which will be applied on the response data to format it. Querying Elasticsearch The first thing we need to do is to implement theQueryInterface. To communicate with Elasticsearch. Spryker uses the Elastica library as aData Query Language. Inside theQueryInterfaceyou need to create an instance of\Elastica\Query, configure it to fit your needs, then return it withgetSearchQuery(). This is the point where configuring the query is completely up to you, use Elastica to alter the query for your needs, add filters, aggregations, boosts, sorting, pagination or anything else you like and Elasticsearch enables you. Tip TheQueryInterfaceinstance is a stateful class; sometimesgetSearchQuery()method is called multiple times and alters the original query (see: Expandig queries), so you need to make sure that it returns the same instance. This can be achieved by creating the\Elastica\Queryinstance atconstruction time and just return it in the getSearchQuery() method. Click to expand the code sample &lt;?php
namespace Pyz\Client\Catalog\Plugin\Query; use Elastica\Query;
use Elastica\Query\MatchAll;
use Generated\Shared\Search\PageIndexMap;
use Spryker\Client\Kernel\AbstractPlugin;
use Spryker\Client\Search\Dependency\Plugin\QueryInterface; class MatchAllQueryPlugin extends AbstractPlugin implements QueryInterface
{ /** * @var \Elastica\Query */ protected $query; /** * @param string $searchString */ public function __construct() { $this-&gt;query = $this-&gt;createSearchQuery(); } /** * @return \Elastica\Query */ public function getSearchQuery() { return $this-&gt;query; } /** * @return \Elastica\Query */ protected function createSearchQuery() { $query = new Query(); $query = $this-&gt;addMatchAllQuery($query); $query-&gt;setSource([PageIndexMap::SEARCH_RESULT_DATA]); return $query; } /** * @param \Elastica\Query $baseQuery * * @return \Elastica\Query */ protected function addMatchAllQuery(Query $baseQuery) { $baseQuery-&gt;setQuery(new MatchAll()); return $baseQuery; } } In the example above, a simple query is created, which will return all the documents from our mapping type. To execute this query you need to call thesearch()method of theSearchClient. Expanding Queries Query expanders are a way to reuse partial queries to build more complex ones. The suggested way to create queries is to create the simplest possible query as a base query for your usecase, then use query expanders to expand it with other reusable behaviours, such as pagination, sorting, etc. You can create a new expander by implementing\Spryker\Client\Search\Dependency\Plugin\QueryExpanderPluginInterface. Again, if you use query expanders, make sure that your base query is expandable, so it provides the same instance by callinggetSearchQuery()multiple times. To expand a base query with a collection of expanders, you’ll need to useexpandQuery()method from theSearchClient. &lt;?php // ... /** * @var \Spryker\Client\Search\SearchClientInterface */ protected $searchClient; // ... /** * @param \Spryker\Client\Search\Dependency\Plugin\QueryInterface $baseQuery * @param \Spryker\Client\Search\Dependency\Plugin\QueryExpanderPluginInterface[] $queryExpanders * @param array $requestParameters * * @return \Spryker\Client\Search\Dependency\Plugin\QueryInterface */ protected function expandBaseQuery(QueryInterface $baseQuery, array $queryExpanders, array $requestParameters) { $searchQuery = $this -&gt;searchClient -&gt;expandQuery($baseQuery, $queryExpanders, $requestParameters); return $searchQuery; } // ... At the moment, Spryker contains three query expander plugins that provide frequently used features. These are all optional to use. Faceted Navigation and Filters The first query expander plugin is the\Spryker\Client\Search\Plugin\Elasticsearch\QueryExpander\FacetQueryExpanderPlugin. Its responsibility is to add the necessary aggregations to your query based on a predefined configuration (see: Configure search features section below). You can use this plugin to get the necessary data for faceted navigation of your search results. If you use this plugin, also make sure to add the\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\FacetResultFormatterPluginto your result formatter collection, which takes care of processing the returned raw aggregation data. Paginating the Results The nextquery expander pluginis the\Spryker\Client\Search\Plugin\Elasticsearch\QueryExpander\PaginatedQueryExpanderPlugin. It takes care of paginating your results based on the predefined configuration. If you use this plugin also make sure to add the\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\PaginatedResultFormatterPluginto your result formatter collection. Sorting the Results The lastquery expander pluginis the \Spryker\Client\Search\Plugin\Elasticsearch\QueryExpander\SortedQueryExpanderPlugin. It takes care of sorting your results based on the predefined configuration. The necessary result formatter for this plugin is \Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\SortedResultFormatterPlugin. Process Query Result After you’ve created your query, you also need to take care of processing the raw response fromElasticsearch. This is done by providing a collection of\Spryker\Client\Search\Dependency\Plugin\ResultFormatterPluginInterface. To create one you need to extend\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\AbstractElasticsearchResultFormatterPlugin. It’s also possible to not provide any result formatters; in this case the raw response will be returned at the end. Click to expand the code sample &lt;?php
namespace Pyz\Client\Catalog\Plugin\ResultFormatter; use Elastica\Result;
use Elastica\ResultSet;
use Generated\Shared\Search\PageIndexMap;
use Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\AbstractElasticsearchResultFormatterPlugin; class DummyResultFormatterPlugin extends AbstractElasticsearchResultFormatterPlugin
{ const NAME = 'test'; /** * @return string */ public function getName() { return static::NAME; } /** * @param \Elastica\ResultSet $searchResult * @param array $requestParameters * * @return array */ protected function formatSearchResult(ResultSet $searchResult, array $requestParameters) { $results = []; foreach ($resultSet-&gt;getResults() as $result) { $results[] = $this-&gt;formatResult($result); } return $results; } /** * @param \Elastica\Result $result * * @return mixed */ protected function formatResult(Result $result) { // Do something with the result ... return $result; } } To execute the previously created query along with this result formatter plugin, you need to call thesearch()method of theSearchClientand provide this formatter to its second parameter. When you use result formatter plugins, the result of theSearchClient::search()method will be an associative array, where the keys are the name of each result formatters (provided bygetName()method) and the values are the response for each result formatter. This way in your controller where at the end you get the response you can simply provide everything you got right to the template to care of. Configure Search Features In this section you’ll learn how to configure faceted navigation, filters, pagination and sorting, so all the important search features that are provided by theSearch (Undefined variable: General.bundle/module). This configuration is only relevant if you enable the three query expanders and result formatters mentioned above. Indirectly, they all require you to provide an instance of\Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterfaceby\Spryker\Client\Search\SearchDependencyProvider::createSearchConfigPlugin()method. So first of all you’ll need to implement this interface. &lt;?php
namespace Pyz\Client\Catalog\Plugin\Config; use Spryker\Client\Kernel\AbstractPlugin;
use Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface; /** * @method \Spryker\Client\Catalog\CatalogFactory getFactory() */
class CatalogSearchConfigBuilder extends AbstractPlugin implements SearchConfigBuilderInterface
{ // ...
} The first method we’ll implement in this interface isbuildFacetConfig()where we configure our facet filters. The goal here is to createFacetConfigTransferinstances with some data and push them for the$facetConfigBuilder. Let’s assume that previously in ourPageMapInterfacewe mapped an integer facet which we called “price” with some data (note the use ofaddIntegerFacet()in the example above), so now we would like to add a price range filter for that data. &lt;?php
namespace Pyz\Client\Catalog\Plugin\Config; use Generated\Shared\Transfer\FacetConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ... /** * @param \Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface $facetConfigBuilder * * @return void */ public function buildFacetConfig(FacetConfigBuilderInterface $facetConfigBuilder) { $priceFacet = (new FacetConfigTransfer()) -&gt;setName('price') -&gt;setParameterName('price') -&gt;setFieldName(PageIndexMap::INTEGER_FACET) -&gt;setType(FacetConfigBuilder::TYPE_PRICE_RANGE); $facetConfigBuilder-&gt;addFacet($priceFacet); } // ... You could create and add as manyFacetConfigTransfersas you need. Let’s analyze this transfer’s options below: setName(): Required field, the name of the target data to filter by. setParameterName(): Required field, the name that will be used in the request when the filter is used. setFieldName(): Required field, the name of the field of the page mapping type where the target data is stored. setType(): Required field, the type of the facet. Currently available options: “enumeration”, “bool”, “range”, “price_range”, “category”. setIsMultiValued(): Optional field, if set totruemultiple values can be filtered with logical OR comparison. The next method we’ll implement is thebuildSortConfig(), where we configure our sorting options. Let’s assume we’d like to sort by name and price and we’ve already added them when we implementedPageMapInterface(note the use ofaddStringSort()andaddIntegerSort()in the example above). Click to expand the code sample &lt;?php
namespace Pyz\Client\Catalog\Plugin\Config; use Generated\Shared\Transfer\SortConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ... /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return void */ public function buildSortConfig(SortConfigBuilderInterface $sortConfigBuilder) { $this -&gt;addAscendingNameSort($sortConfigBuilder) -&gt;addDescendingNameSort($sortConfigBuilder) -&gt;addAscendingPriceSort($sortConfigBuilder) -&gt;addDescendingPriceSort($sortConfigBuilder); } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addAscendingNameSort(SortConfigBuilderInterface $sortConfigBuilder) { $ascendingNameSortConfig = (new SortConfigTransfer()) -&gt;setName('name') -&gt;setParameterName('name_asc') -&gt;setFieldName(PageIndexMap::STRING_SORT); $sortConfigBuilder-&gt;addSort($ascendingNameSortConfig); return $this; } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addDescendingNameSort(SortConfigBuilderInterface $sortConfigBuilder) { $ascendingNameSortConfig = (new SortConfigTransfer()) -&gt;setName('name') -&gt;setParameterName('name_desc') -&gt;setFieldName(PageIndexMap::STRING_SORT) -&gt;setIsDescending(true); $sortConfigBuilder-&gt;addSort($ascendingNameSortConfig); return $this; } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addAscendingPriceSort(SortConfigBuilderInterface $sortConfigBuilder) { $priceSortConfig = (new SortConfigTransfer()) -&gt;setName('price') -&gt;setParameterName('price_asc') -&gt;setFieldName(PageIndexMap::INTEGER_SORT); $sortConfigBuilder-&gt;addSort($priceSortConfig); return $this; } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addDescendingPriceSort(SortConfigBuilderInterface $sortConfigBuilder) { $priceSortConfig = (new SortConfigTransfer()) -&gt;setName('price') -&gt;setParameterName('price_desc') -&gt;setFieldName(PageIndexMap::INTEGER_SORT) -&gt;setIsDescending(true); $sortConfigBuilder-&gt;addSort($priceSortConfig); return $this; } // ... Similar to facet filters, here you can create and add as manySortConfigTransfersas you need. The transfer’s options are the following: setName(): Required field, the name of the target data to sort by. setParameterName(): Required field, the name that will be used in the request when the sort is used. setFieldName(): Required field, the name of the field of the page mapping type where the target data is stored.. setIsDescending(): Optional field, the sort direction is descending when this is set to true otherwise the sort direction is ascending by default. Sort by relevance Note that Elasticsearch is by default sorting by relevance. The cost of each document is calculated based on your search query. The last method we’ll need to implement in theCatalogSearchConfigBuilderis thebuildPaginationConfig()to configure the pagination of the results. Click to expand the code sample &lt;?php
namespace Pyz\Client\Catalog\Plugin\Config; use Generated\Shared\Transfer\PaginationConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ... const DEFAULT_ITEMS_PER_PAGE = 6; const VALID_ITEMS_PER_PAGE_OPTIONS = [6, 18, 36]; /** * @param \Spryker\Client\Search\Dependency\Plugin\PaginationConfigBuilderInterface $paginationConfigBuilder * * @return void */ public function buildPaginationConfig(PaginationConfigBuilderInterface $paginationConfigBuilder) { $paginationConfigTransfer = (new PaginationConfigTransfer()) -&gt;setParameterName('page') -&gt;setItemsPerPageParameterName('ipp') -&gt;setDefaultItemsPerPage(self::DEFAULT_ITEMS_PER_PAGE) -&gt;setValidItemsPerPageOptions(self::VALID_ITEMS_PER_PAGE_OPTIONS); $paginationConfigBuilder-&gt;setPagination($paginationConfigTransfer); } // ... This time we need to create only one instance fromPaginationConfigTransferand set it in the$paginationConfigBuilder. The transfer’s options are the following: setParameterName(): Required field, the name that will be used in the request for the current page. setItemsPerPageParameterName(): Optional field, if defined this name will be used in the request for changing the items per page parameter. setDefaultItemsPerPage(): Optional field, the value of the default items per page. setValidItemsPerPageOptions(): Optional field, an array of valid items per page options. After fully implementing the config builder plugin, we’ll need to provide it on project level in theSearchDependencyProvider. Click to expand the code sample &lt;?php
namespace Pyz\Client\Search; use Pyz\Client\Catalog\Plugin\Config\CatalogSearchConfigBuilder;
use Spryker\Client\Kernel\Container;
use Spryker\Client\Search\SearchDependencyProvider as SprykerSearchDependencyProvider; class SearchDependencyProvider extends SprykerSearchDependencyProvider
{ /** * @param \Spryker\Client\Kernel\Container $container * * @return \Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface */ protected function createSearchConfigBuilderPlugin(Container $container) { return new CatalogSearchConfigBuilder(); } } After you provided the instance of your search configuration builder, theexpanderandresult formatterplugins will start to generate data next time you’ll run a search query. This tutorial doesn’t cover how to display the filters, but you can find examples using them in our Demoshop.</body>
</html>