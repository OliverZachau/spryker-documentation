<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Spryker provides a convenient way to search product data. You’re enabled to easily setup full-text and facet search. In this tutorial we will show how to implement a simple product search using Spryker. This tutorial will not cover all aspects in detail to keep it focused. There will be links throughout the article that will lead you to in depth articles on related topics. If you want to dive deeper into the search topic there’s a number of additional articles that cover various topics. Search Collector If you’re not familiar with the concept of collectors yet I highly recommend reading the article onCollectors. In order to provide data for the search index you will need to implement a dedicated collector and a processor for the product data mapping. Collector The collector that collects data and pushes it toElasticsearchisProductCollector(Pyz/Zed/Collector/Business/Search). The main operations performed by the search collector are : createQuery()- creates the query for gathering the data from the Sql database processData()- transforms the result of the database query into the format that’s stored in the Elasticsearch storage Product Processor When processing the query result, the mapping of the query result to the Elasticsearch structure is done through theProductSearchProcessor. Example : $baseProduct['integer-sort']['size'] = isset($attributes['size']) ? $attributes['size'] : 0; The line above would allow to perform an integer sort based on the values of the size field, by setting this attribute in the Elasticsearch data storage. After you have set up the collector and processor you need to hook it up as a plugin to thecollector:search:exportconsole command. Details about how to setup console commands can be found in the Console article. Introduction to the Search Client You can access the search from within Yves using theCatalog (Undefined variable: General.bundle/module)’s clientSpryker\Client\Catalog\CatalogClient. This client provides two methods that can be used to query the search index createFulltextSearch() - the search is made on all products; multiple filter criteria can be applied createFacetSearch() - the search is made over a category of products; multiple filter criteria can be applied SimpleSearch(Undefined variable: General.bundle/module)(full-text search) To exemplify how the search functionality works, we’ll add a new(Undefined variable: General.bundle/module)that will contain these examples, calledSimpleSearch. The new(Undefined variable: General.bundle/module)will be added on the project side, in the Yves folder (because it’s a functionality we’ll exemplify in Yves). These are the steps we will cover: Set up a controller to handle requests and communicate with the search client Set up a template to show results Set up URL routing to access the controller Controller and Template User interface interactions will be forwarded to a dedicated controller that will take care of the communication with the search client. Controller mkdir -p src/Pyz/Yves/SimpleSearch/Communication/Controller
touch src/Pyz/Yves/SimpleSearch/Communication/Controller/SimpleSearchController.php Add an action in the controller that submits a full-text search and returns the results : &lt;?php
namespace Pyz\Yves\SimpleSearch\Communication\Controller; use Spryker\Yves\Application\Communication\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request; class SimpleSearchController extends AbstractController
{ /** * @param Request $request * * @return array */ public function fullTextSearchAction(Request $request) { $search = $this-&gt;getLocator()-&gt;catalog()-&gt;client()-&gt;createFulltextSearch($request); $searchResults = $search-&gt;getResult(); return $searchResults; } } Template Next, add the view template for showing the list of products : mkdir -p src/Pyz/Yves/SimpleSearch/Theme/default/simple-search
touch src/Pyz/Yves/SimpleSearch/Theme/default/simple-search/full-text-search.twig The template will be simple ( it will only show the name and price of the products, with a link to the products page). The price will be formatted by using the price twig extension. Place the following content into the full-text-search.twig file : {% extends "@application/layout/layout.twig" %}
{% block content %} &lt;/br&gt; &lt;div&gt; &lt;section &gt; {% for product in products %} &lt;article&gt; &lt;a href="{{product.url}}"&gt; &lt;h2&gt;{{product.abstract_name}}&lt;/h2&gt; &lt;h2&gt;{{ product.valid_price | price }}&lt;/h2&gt; &lt;/a&gt; &lt;/article&gt; {% endfor %} &lt;/section&gt; &lt;/div&gt;
{% endblock %} You can find in-depth coverage on controllers and templates in the Controllers and Actions article. Routing There are a couple of steps involved to set up routing to the newly created controller. We will need to add some dependencies to ourSimpleSearchBundlethat will be required by the router. Please read the article URL Routing to get more in-depth coverage on this topic. For brevity sake of this article we will skip over details and show the implementation to get routing for the URL/full-text-searchto thefullTextSearchActioncontroller action ofSimpleSearchControllerworking. Add a router to map the URL to theFullTextSearchaction: mkdir -p src/Pyz/Yves/SimpleSearch/Communication/Plugin/Router
touch src/Pyz/Yves/SimpleSearch/Communication/Plugin/Router/FullTextSearchRouter.php Route the URL to the action you added in theSimpleSearchController: Click to expand the code sample &lt;?php
namespace Pyz\Yves\SimpleSearch\Communication\Plugin\Router; use Spryker\Yves\Kernel\Locator;
use Spryker\Shared\Application\Communication\ControllerServiceBuilder;
use Spryker\Yves\Application\Business\Routing\AbstractRouter;
use Spryker\Yves\Kernel\Communication\BundleControllerAction;
use Spryker\Yves\Kernel\Communication\Controller\RouteNameResolver;
use Spryker\Yves\Kernel\Communication\ControllerLocator;
use Pyz\Yves\SimpleSearch\Communication\SimpleSearchCommunicationFactory;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\RouteNotFoundException; /** * @method Pyz\Yves\SimpleSearch\Communication\SimpleSearchCommunicationFactory getFactory() */
class FullTextSearchRouter extends AbstractRouter
{ /** * @throws \Symfony\Component\Routing\Exception\RouteNotFoundException * * @param string $name * @param array $parameters * @param string $referenceType * * @return void */ public function generate($name, $parameters = [], $referenceType = static::ABSOLUTE_PATH) { if ('/full-text-search' === $name) { $request = $this-&gt;getRequest(); $requestParameters = $request-&gt;query-&gt;all(); if (!isset($parameters['page']) &amp;&amp; isset($requestParameters['page'])) { unset($requestParameters['page']); } $pathInfo = $this-&gt;getUrlMapper()-&gt;generateUrlFromParameters( $this-&gt;getUrlMapper()-&gt;mergeParameters($requestParameters, $parameters) ); $pathInfo = $name . $pathInfo; return $this-&gt;getUrlOrPathForType($pathInfo, $referenceType); } throw new RouteNotFoundException(); } /** * @throws \Symfony\Component\Routing\Exception\ResourceNotFoundException * * @param string $pathinfo * * @return void */ public function match($pathinfo) { if ($pathinfo === '/full-text-search') { $request = $this-&gt;getRequest(); $this-&gt;getUrlMapper()-&gt;injectParametersFromUrlIntoRequest($pathinfo, $request); $bundleControllerAction = new BundleControllerAction('SimpleSearch', 'SimpleSearch', 'fullTextSearch'); $controllerResolver = new ControllerLocator($bundleControllerAction); $routeResolver = new RouteNameResolver('Simplesearch'); $service = (new ControllerServiceBuilder())-&gt;createServiceForController( $this-&gt;getApplication(), Locator::getInstance(), $bundleControllerAction, $controllerResolver, $routeResolver ); return [ '_controller' =&gt; $service, '_route' =&gt; $routeResolver-&gt;resolve(), ]; } throw new ResourceNotFoundException(); } /** * @return \Pyz\Yves\FrontendExporter\Communication\Mapper\UrlMapperInterface */ private function getUrlMapper() { return $this-&gt;getFactory()-&gt;createUrlMapper(); } /** * @return \Symfony\Component\HttpFoundation\Request */ private function getRequest() { $application = $this-&gt;getApplication(); $request = ($application['request_stack']) ? $application['request_stack']-&gt;getCurrentRequest() : $application['request']; return $request; } /** * @return \Silex\Application */ private function getApplication() { return $this-&gt;getFactory()-&gt;createApplication(); }
} Register the new added router in YvesBootstrap : &lt;?php
/** * @param Application $app * * @return RouterInterface[] */
protected function getRouters(Application $app)
{ $locator = $this-&gt;getLocator($app); return [ //.. $locator-&gt;simplesearch()-&gt;pluginRouterFulltextSearchRouter()-&gt;setSsl(false), new SilexRouter($app), ];
} To have access to the necessary dependencies, add a communication factory under the Communication layer: touch src/Pyz/Yves/SimpleSearch/Communication/SimpleSearchCommunicationFactory.php Place the following code in your communication factory: Click to expand the code sample &lt;?php
namespace Pyz\Yves\SimpleSearch\Communication; use Spryker\Zed\Kernel\Communication\AbstractCommunicationFactory; class SimpleSearchCommunicationFactory extends AbstractCommunicationFactory
{ /** * @return \Pyz\Yves\FrontendExporter\Communication\Mapper\UrlMapperInterface */ public function createUrlMapper() { return $this-&gt;getLocator()-&gt;frontendExporter()-&gt;pluginUrlMapper()-&gt;createUrlMapper(); } /** * @return \Silex\Application */ public function createApplication() { return $this-&gt;getLocator()-&gt;application()-&gt;pluginPimple()-&gt;getApplication(); } } Testing the Implementation If you navigate to http://www.de.demoshop.local/full-text-search?q=brown in your browser of choice you will see search results for products that match the termbrown. You can also add filters or sort the results on various criteria, as in the examples below : http://www.de.demoshop.local/fulltextsearch?q=brown&amp;price=0-7 http://www.de.demoshop.local/fulltextsearch?q=Seepferdchen&amp;main_color=red&amp;sort=name&amp;sort_order=asc Adding Pagination Paginating results is already built in and easy to set up. You only need to slightly change the implementation of thefullTextSearchActioninSimpleSearchController. Add the following line of code somewhere before$searchResults = $search-&gt;getResult();infullTextSearchActio $search-&gt;setItemsPerPage(10); In the search view template, add navigation buttons to browse the results : &lt;div class="catalog__pagination"&gt; &lt;button class="pagination__button js-pagination-prev"&gt;catalog.prev&lt;/button&gt; &lt;button class="pagination__button js-pagination-next"&gt;catalog.next&lt;/button&gt;
&lt;/div&gt; Facets and Sorting After the data is correctly collected and stored in Elasticsearch in the best suited format, Yves must be able to build a query request that the Elasticsearch service can understand in order to get the correct search results. Each attribute after which we need to build a search query must be configured in FacetConfig, so that the request is correctly being built. Example : &lt;?php
'size' =&gt; [ static::KEY_FACET_ACTIVE =&gt; true, static::KEY_SORT_ACTIVE =&gt; true, static::KEY_FACET_FIELD_NAME =&gt; static::FIELD_INTEGER_FACET, static::KEY_TYPE =&gt; static::TYPE_ENUMERATION, static::KEY_PARAM =&gt; 'size',
] The configuration above allows to perform a search using thesizeattribute, which is stored under the integer facet and to sort the results on this value.</body>
</html>