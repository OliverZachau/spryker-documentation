<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>In this section you’ll learn how to configure faceted navigation, filters, pagination and sorting, so all the important search features that are provided by theSearch (Undefined variable: General.bundle/module). This configuration is only relevant if you enable the three query expanders and result formatters mentioned above. Indirectly, they all require you to provide an instance of\Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterfaceby\Spryker\Client\Search\SearchDependencyProvider::createSearchConfigPlugin()method. So first of all you’ll need to implement this interface. &lt;?php namespace Pyz\Client\Catalog\Plugin\Config; use Spryker\Client\Kernel\AbstractPlugin;
use Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface; /** * @method \Spryker\Client\Catalog\CatalogFactory getFactory() */
class CatalogSearchConfigBuilder extends AbstractPlugin implements SearchConfigBuilderInterface
{ // ...
} The first method we’ll implement in this interface isbuildFacetConfig()where we configure our facet filters. The goal here is to createFacetConfigTransferinstances with some data and push them for the$facetConfigBuilder. Let’s assume that previously in ourPageMapInterfacewe mapped an integer facet which we called “price” with some data (note the use ofaddIntegerFacet()in the example above), so now we would like to add a price range filter for that data. &lt;?php namespace Pyz\Client\Catalog\Plugin\Config; use Generated\Shared\Transfer\FacetConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ... /** * @param \Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface $facetConfigBuilder * * @return void */ public function buildFacetConfig(FacetConfigBuilderInterface $facetConfigBuilder) { $priceFacet = (new FacetConfigTransfer()) -&gt;setName('price') -&gt;setParameterName('price') -&gt;setFieldName(PageIndexMap::INTEGER_FACET) -&gt;setType(FacetConfigBuilder::TYPE_PRICE_RANGE); $facetConfigBuilder-&gt;addFacet($priceFacet); } // ... You could create and add as manyFacetConfigTransfersas you need. Let’s analyze this transfer’s options below: setName():Requiredfield, the name of the target data to filter by. setParameterName():Requiredfield, the name that will be used in the request when the filter is used. setFieldName():Requiredfield, the name of the field of the page mapping type where the target data is stored. setType():Requiredfield, the type of the facet. Currently available options: “enumeration”, “bool”, “range”, “price_range”, “category”. setIsMultiValued():Optionalfield, if set totruemultiple values can be filtered with logical OR comparison. setSize():Optionalfield, the maximum number of filter options to be returned (0 means unlimited). Elasticsearch returns 10 options by default. setValueTransformer():Optionalfield, to provide a value transformer plugin by defining the Fully Qualified Name of the plugin. This plugin needs to implement\Spryker\Client\Search\Dependency\Plugin\FacetSearchResultValueTransformerPluginInterface. It's used to transform each filter value from their stored values (for example IDs) to something readable (representing name) for users. The next method we’ll implement is thebuildSortConfig(), where we configure our sorting options. Let’s assume we’d like to sort by name and price and we’ve already added them when we implementedPageMapInterface(note the use ofaddStringSort()andaddIntegerSort()in the example above). Click to expand the code sample &lt;?php namespace Pyz\Client\Catalog\Plugin\Config; use Generated\Shared\Transfer\SortConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ... /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return void */ public function buildSortConfig(SortConfigBuilderInterface $sortConfigBuilder) { $this -&gt;addAscendingNameSort($sortConfigBuilder) -&gt;addDescendingNameSort($sortConfigBuilder) -&gt;addAscendingPriceSort($sortConfigBuilder) -&gt;addDescendingPriceSort($sortConfigBuilder); } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addAscendingNameSort(SortConfigBuilderInterface $sortConfigBuilder) { $ascendingNameSortConfig = (new SortConfigTransfer()) -&gt;setName('name') -&gt;setParameterName('name_asc') -&gt;setFieldName(PageIndexMap::STRING_SORT); $sortConfigBuilder-&gt;addSort($ascendingNameSortConfig); return $this; } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addDescendingNameSort(SortConfigBuilderInterface $sortConfigBuilder) { $ascendingNameSortConfig = (new SortConfigTransfer()) -&gt;setName('name') -&gt;setParameterName('name_desc') -&gt;setFieldName(PageIndexMap::STRING_SORT) -&gt;setIsDescending(true); $sortConfigBuilder-&gt;addSort($ascendingNameSortConfig); return $this; } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addAscendingPriceSort(SortConfigBuilderInterface $sortConfigBuilder) { $priceSortConfig = (new SortConfigTransfer()) -&gt;setName('price') -&gt;setParameterName('price_asc') -&gt;setFieldName(PageIndexMap::INTEGER_SORT); $sortConfigBuilder-&gt;addSort($priceSortConfig); return $this; } /** * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder * * @return $this */ protected function addDescendingPriceSort(SortConfigBuilderInterface $sortConfigBuilder) { $priceSortConfig = (new SortConfigTransfer()) -&gt;setName('price') -&gt;setParameterName('price_desc') -&gt;setFieldName(PageIndexMap::INTEGER_SORT) -&gt;setIsDescending(true); $sortConfigBuilder-&gt;addSort($priceSortConfig); return $this; } // ... Similar to facet filters, here you can create and add as manySortConfigTransfersas you need. The transfer’s options are the following: setName():Requiredfield, the name of the target data to sort by. setParameterName():Requiredfield, the name that will be used in the request when the sort is used. setFieldName():Requiredfield, the name of the field of the page mapping type where the target data is stored.. setIsDescending():Optionalfield, the sort direction is descending when this is set to true otherwise the sort direction is ascending by default. Sort by relevance Note that Elasticsearch is by default sorting by relevance. The cost of each document is calculated based on your search query. The last method we’ll need to implement in theCatalogSearchConfigBuilderis thebuildPaginationConfig()to configure the pagination of the results. &lt;?php namespace Pyz\Client\Catalog\Plugin\Config; use Generated\Shared\Transfer\PaginationConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ... const DEFAULT_ITEMS_PER_PAGE = 6; const VALID_ITEMS_PER_PAGE_OPTIONS = [6, 18, 36]; /** * @param \Spryker\Client\Search\Dependency\Plugin\PaginationConfigBuilderInterface $paginationConfigBuilder * * @return void */ public function buildPaginationConfig(PaginationConfigBuilderInterface $paginationConfigBuilder) { $paginationConfigTransfer = (new PaginationConfigTransfer()) -&gt;setParameterName('page') -&gt;setItemsPerPageParameterName('ipp') -&gt;setDefaultItemsPerPage(static::DEFAULT_ITEMS_PER_PAGE) -&gt;setValidItemsPerPageOptions(static::VALID_ITEMS_PER_PAGE_OPTIONS); $paginationConfigBuilder-&gt;setPagination($paginationConfigTransfer); } // ... This time we need to create only one instance fromPaginationConfigTransferand set it in the$paginationConfigBuilder. The transfer’s options are the following: setParameterName():Requiredfield, the name that will be used in the request for the current page. setItemsPerPageParameterName():Optionalfield, if defined this name will be used in the request for changing the items per page parameter. setDefaultItemsPerPage():Optionalfield, the value of the default items per page. setValidItemsPerPageOptions():Optionalfield, an array of valid items per page options. After fully implementing the config builder plugin, we’ll need to provide it on project level in theSearchDependencyProvider. &lt;?php namespace Pyz\Client\Search; use Pyz\Client\Catalog\Plugin\Config\CatalogSearchConfigBuilder;
use Spryker\Client\Kernel\Container;
use Spryker\Client\Search\SearchDependencyProvider as SprykerSearchDependencyProvider; class SearchDependencyProvider extends SprykerSearchDependencyProvider
{ /** * @param \Spryker\Client\Kernel\Container $container * * @return \Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface */ protected function createSearchConfigBuilderPlugin(Container $container) { return new CatalogSearchConfigBuilder(); } } After you provided the instance of your search configuration builder, theexpanderandresult formatterplugins will start to generate data next time you’ll run a search query. This tutorial doesn’t cover how to display the filters, but you can find examples using them in our Demoshop.</body>
</html>