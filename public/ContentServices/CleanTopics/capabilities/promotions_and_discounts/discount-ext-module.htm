<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Extending the Discount(Undefined variable: General.Bundle/Module) The main components that describe a discount are: discount collector: Specifies for which items discount is being applied/calculated. Example: The discount can be applied for a specific set of products or for orders that contain a minimum number of items or for orders that have a minimum grand total value. discount decisionrule: Specifies the conditions that need to be satisfied for the discount to be applied. Example: The discount can be used on specific days of the week or on specific time intervals in a day. discount filteris applied to disountable items after collector had been run, filters are executed after each discount allowed explicit filtering. discount collector strategy: It's possible to change what collector strategy is used when collecting items for discounts, by default query string strategy is used. Collecting items by defined rule. discount post save: This extension allows to add more behaviour to discounts after discount saved. discount post update: This extension allows to add more behaviour to discounts after discount updated. discount configuration expander: This extension allows to add more data to DiscountConfigurationTransfer object. This object later mapped to discount form. discount form expander: This extension allows to extend the discount form. discount form data provider expander: This extension allows adding additional data to discount form data provider. discount view block provider: This extension allows adding additional blocks to discount view page. discount applicable filter plugin: This extension allows to filter quote items before passing to query builder (decision rule). For example you can filter items you don't want to match all your rules. The decision rule associated with the discount always runs first; if it is satisfied, the collector is run so that the discount calculation can be performed on the collected items. TheDiscountmodule already contains a set of discount collectors and decision rules, but depending on your needs, you can extend it with your own ones. Adding a New Decision Rule The decision rules are placed in theBusiness/DecisionRule/folder from theDiscount (Undefined variable: General.bundle/module)in Zed. A decision rule must implement theDecisionRuleInterface. You’ll need to implement theisSatisfiedBy()method that returns a boolean value that states if the decision rule is satisfied. Example: &lt;?php /** * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer * @param \Generated\Shared\Transfer\ItemTransfer $currentItemTransfer * @param \Generated\Shared\Transfer\ClauseTransfer $clauseTransfer * * @throws \Spryker\Zed\Discount\Business\Exception\ComparatorException * * @return bool */ public function isSatisfiedBy( QuoteTransfer $quoteTransfer, ItemTransfer $currentItemTransfer, ClauseTransfer $clauseTransfer ) { return $this-&gt;comparators-&gt;compare($clauseTransfer, $currentItemTransfer-&gt;getSku()); } In the example above, we are checking if the given item is matching the clause (has the same SKU). To use the query comparators, you need to inject them in the constructor of your new decision rule. The next step is to expose the new decision rule through the facade: extend theDiscountFacadeby adding a new operation that exposes its functionality. &lt;?php /** * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer * @param \Generated\Shared\Transfer\ItemTransfer $itemTransfer * @param \Generated\Shared\Transfer\ClauseTransfer $clauseTransfer * * @return bool */ public function isItemSkuSatisfiedBy( QuoteTransfer $quoteTransfer, ItemTransfer $itemTransfer, ClauseTransfer $clauseTransfer ) { return $this-&gt;getFactory() -&gt;createSkuDecisionRule() -&gt;isSatisfiedBy($quoteTransfer, $itemTransfer, $clauseTransfer); } Create a plugin that calls the facade operation you have just added. The plugin must be placed inside theCommunication/Plugin/DecisionRule/folder from theDiscountmodule . The decision rule plugin must implement theDecisionRulePluginInterface. Besides calling the discount decision rule to check if the discount can be applied, the plugin also defines the name of the field to which we’re performing the comparison, as well as the accepted data types. &lt;?php
class SkuDecisionRulePlugin extends AbstractPlugin implements DecisionRulePluginInterface
{ /** * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer * @param \Generated\Shared\Transfer\ItemTransfer $itemTransfer * @param \Generated\Shared\Transfer\ClauseTransfer $clauseTransfer * * @return bool */ public function isSatisfiedBy(QuoteTransfer $quoteTransfer, ItemTransfer $itemTransfer, ClauseTransfer $clauseTransfer) { return $this-&gt;getFacade() -&gt;isItemSkuSatisfiedBy($quoteTransfer, $itemTransfer, $clauseTransfer); } /** * Name of field as used in query string * * @return string */ public function getFieldName() { return 'sku'; } /** * @return array */ public function acceptedDataTypes() { return [ ComparatorOperators::TYPE_STRING, ComparatorOperators::TYPE_LIST, ]; } } The last step is to register the plugin so that it’s available in the discount plugin stack. Extend theDiscountDependencyProvider::getDecisionRulePlugins()and add the new decision rule to the stack. Adding a New Collector Adding a new collector is similar to adding a new decision rule. The discount collectors are placed inside theBusiness/Collector/folder from theDiscountmodule in Zed. A collector must implement theCollectorInterfaceand must extend theBaseCollectorclass that offers support for creating the discountable items. You’ll need to implement thecollect()method that returns the set of items on which the discount can be applied. Example: &lt;?php /** * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer * @param \Generated\Shared\Transfer\ClauseTransfer $clauseTransfer * * @return \Generated\Shared\Transfer\DiscountableItemTransfer[] */ public function collect(QuoteTransfer $quoteTransfer, ClauseTransfer $clauseTransfer) { $discountableItems = []; foreach ($quoteTransfer-&gt;getItems() as $itemTransfer) { if ($this-&gt;comparators-&gt;compare($clauseTransfer, $itemTransfer-&gt;getSku()) === false) { continue; } $discountableItems[] = $this-&gt;createDiscountableItemTransfer( $itemTransfer-&gt;getUnitGrossPrice(), $itemTransfer-&gt;getQuantity(), $itemTransfer-&gt;getCalculatedDiscounts() ); } return $discountableItems; } In the example above, we are looking over the items included in the order and select the ones that have the SKU specified in the collector clause. To use the query comparators, you need to inject them in the constructor of your new discount collector. The next step is to expose the new collector through the facade: extend theDiscountFacadeby adding a new operation that exposes its functionality. &lt;?php /** * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer * @param \Generated\Shared\Transfer\ClauseTransfer $clauseTransfer * * @return array */ public function collectBySku(QuoteTransfer $quoteTransfer, ClauseTransfer $clauseTransfer) { return $this-&gt;getFactory() -&gt;createSkuCollector() -&gt;collect($quoteTransfer, $clauseTransfer); } Create a plugin that calls the facade operation you have just added. The plugin must be placed inside theCommunication/Plugin/Collector/folder from theDiscountmodule. The discount collector plugin must implement theCollectorPluginInterface. Besides calling the discount collector to retrieve the items for which the discount can be applied, the plugin also defines the name of the field to which we’re performing the comparison, as well as the accepted data types. &lt;?php
class ItemBySkuCollectorPlugin extends AbstractPlugin implements CollectorPluginInterface
{ /** * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer * @param \Generated\Shared\Transfer\ClauseTransfer $clauseTransfer * * @return array */ public function collect(QuoteTransfer $quoteTransfer, ClauseTransfer $clauseTransfer) { return $this-&gt;getFacade()-&gt;collectBySku($quoteTransfer, $clauseTransfer); } /** * Name of field as used in query string * * @return string */ public function getFieldName() { return 'sku'; } /** * @return array */ public function acceptedDataTypes() { return [ ComparatorOperators::TYPE_STRING, ComparatorOperators::TYPE_LIST, ]; } } The last step is to register the plugin so that it’s available in the discount plugin stack. Extend theDiscountDependencyProvider::getCollectorPlugins()and add the new discount collector to the stack. Adding a Discount Filter Plugin If you extended\Spryker\Zed\Discount\Business\Calculator\Calculatorin your project code, change it to\Spryker\Zed\Discount\Business\Calculator\FilteredCalculator, as it also includes filtering related logic. To add a new filter plugin, create a plugin in your respective module which implements\Spryker\Zed\Discount\Dependency\Plugin\DiscountableItemFilterPluginInterface. The filter will send\Generated\Shared\Transfer\CollectedDiscountTransferto your plugin for each applicable discount. To filter out discounts, remove items from\Generated\Shared\Transfer\CollectedDiscountTransfer::$discountableItems. If you return an empty collection, then this discount will not be applied. Add your plugin to the plugin stack\Spryker\Zed\Discount\DiscountDependencyProvider::getDiscountableItemFilterPluginsextended by a project. After this all discounts will be filtered by the provided plugins. Creating a New Discount Collector Strategy Plugin Discount module distributes discount amount to discountable items. For this there is a collector which returns the list of items to which discount can be applied. If you want to have custom logic how this is collected, then you can implement a different collector strategy. You will need to implement\Spryker\Zed\Discount\Dependency\Plugin\CollectorStrategyPluginInterface. This interface has two methods, the first\Spryker\Zed\Discount\Dependency\Plugin\CollectorStrategyPluginInterface::accept(DiscountTransfer $discountTransfer, QuoteTransfer $quoteTransfer) must return true for a given discount if current strategy is applicable. DiscountTransfer and QuoteTransfer are provided for additional context when making decision. The second,\Spryker\Zed\Discount\Dependency\Plugin\CollectorStrategyPluginInterface::collect(DiscountTransfer $discountTransfer, QuoteTransfer $quoteTransfer)must return DiscountableItemTransfer array, this is the items to which discount will be applied. You have to create a new plugin in your module and place it to for exampleCommunication/Plugins/Discount/NameOfPlugin.php, add this plugin to Discount module dependency provider, by modifying\Pyz\Zed\Discount\DiscountDependencyProvider::getCollectorStrategyPlugins() The method would look like:/** * @return \Spryker\Zed\Discount\Dependency\Plugin\CollectorStrategyPluginInterface[] */ protected function getCollectorStrategyPlugins() { return [ new NameOfPlugin(), ]; } After this the new collector should be ready for use. Adding a Discount Post Save Plugin If you want to add more behavior after the discount is saved, you can implement\Spryker\Zed\Discount\Dependency\Plugin\DiscountPostSavePluginInterfaceplugin interface. Create a new plugin which implements the interface, place plugin in your module underCommunication/Plugins/Discount/NameOfPlugin(). Add this plugin to`\Pyz\Zed\Discount\DiscountDependencyProvider::getDiscountPostSavePlugins`plugin stack. After this the new post save plugin should be ready for use. Adding a Discount Post Update Plugin If you want to add more behavior after discount is updated, you can implement\Spryker\Zed\Discount\Dependency\Plugin\DiscountPostUpdatePluginInterfaceplugin interface. Create a new plugin which implements the interface, place plugin in your module underCommunication/Plugins/Discount/NameOfPlugin(). Add this plugin to`\Pyz\Zed\Discount\DiscountDependencyProvider::getDiscountPostUpdatePlugins`plugin stack. After this the new post save plugin should be ready for use. Adding a Discount Configuration Expander Plugin If you want to expandDiscountConfigurationTransferwith additional data, you can create a new plugin implementing\Spryker\Zed\Discount\Dependency\Plugin\DiscountConfigurationExpanderPluginInterface Create a new plugin which implements the interface, place plugin in your module underCommunication/Plugins/Discount/NameOfPlugin(). Add this plugin to`\Pyz\Zed\Discount\DiscountDependencyProvider::getDiscountConfigurationExpanderPlugins`plugin stack. After this the new expander pluing should be ready for use. Adding a Discount Form Expander Plugin It's possible to extend ZED discount administration form. To inject new form fields, you have to implement\Spryker\Zed\Discount\Dependency\Plugin\Form\DiscountFormExpanderPluginInterfaceplugin interface. This plugin has 1 method: public function expandFormType(FormBuilderInterface $builder, array $options)is the method used to add new properties to Discount form. You have to use $builder object to extend Discount form. reference you can check implementation of\Spryker\Zed\DiscountPromotion\Communication\Plugin\Discount\DiscountPromotionCalculationFormExpanderPluginwhich adds two new form fields to Discount Calculation form. Adding a Discount Form Data Expander Plugin This plugin allows to add additional data to discount form data provider To add additional data to discount form,\Spryker\Zed\Discount\Dependency\Plugin\Form\DiscountFormDataProviderExpanderPluginInterfaceplugin interface should be implemented. This plugin has 2 methods: public function expandDataProviderOptions(array $options);: This method must return extended option array which will be passed to DiscountForm. public function expandDataProviderData(array $data);: This method must return extended data array which will be passed to DiscountForm. Add this plugin to:\Pyz\Zed\Discount\DiscountDependencyProvider::getDiscountFormDataProviderExpanderPlugins Rendering Additional Data Inside Discount View Page You can provide URL to your action which will include rendered html at the bottom of the discount view page. It is necessary to implement\Spryker\Zed\Discount\Dependency\Plugin\DiscountViewBlockProviderPluginInterfaceplugin interface. This plugin has single methodpublic function getUrl()which must return URL path to controller action, for example"/discount/block/index". Add this plugin to:\Pyz\Zed\Discount\DiscountDependencyProvider::getDiscountViewTemplateProviderPlugins Filter Applicable Discounts Before Query Rule Engine You can filter out quote items before making them match your decision rule. For example, you don't want matching promotion items. This filter will be applicable to all decision rules. Each plugin is narrowing down applicable items. For example when you have two plugins, second plugin will receive items filtered by the first one. It is necessary to implement\Spryker\Zed\Discount\Dependency\Plugin\DiscountApplicableFilterPluginInterfaceplugin interface. This plugin has single methodpublic function filter(array $discountApplicableItems, QuoteTransfer $quoteTransfer, $idDiscount);which must return array ofItemTransfer[]object applicable for discount. Add this plugin to:\Pyz\Zed\Discount\DiscountDependencyProvider::getDiscountApplicableFilterPlugins Last review date: Sep. 1, 2017</body>
</html>