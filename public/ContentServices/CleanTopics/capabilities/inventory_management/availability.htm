<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>For most of the e-commerce platforms stock does not reflect real availability of products, since stock is just the physical number of products in your warehouse which does not take reserved products into account. In contrast to stock, availability considers not just number of products in the warehouse, but current open orders as well. In general, product availability defines if the product can or cannot be sold in the shop. From this article you will get to know how product availability is checked and calculated, how products are reserved, what the availability collector does, how availability can be imported to the database as well as how availability per store works. Availability Check The process of checking product's availability implies several operations described in the list below. Product details page won’t show theAdd to cartbutton when concrete product is out of stock. Instead informational message is displayed. Pre-check plugin in cart. \Spryker\Zed\AvailabilityCartConnector\Communication\Plugin\CheckAvailabilityPlugin checks if all items in cart are available. It’s executed after "Add to cart" operation. If an item is not available, an error message is sent to Yves. Checkout pre-condition when order is placed in last step.Spryker\Zed\Availability\Communication\Plugin\ProductsAvailableCheckoutPre ConditionPluginchecks all items in cart. If any of them is not available anymore, order placing is aborted and error message is displayed. "Reserved" Flag When order is placed, payment state machine is executed and item is moved through states. Some states have a “reserved” flag which means that the state influences the item availability. When items are moved to state with the "reserved" flag,ReservationHandlerPluginInterface::handle()is triggered. This call means that the product availability has to be updated. State machine is also tracking products in "reserved" state, and database tablespy_oms_product_reservationis used for this. Below you can see dummy payment state machine, which is a sample implementation with "reserved" flags: Availability Collector The availability collector collects all availability information from abstract product to concrete. Items are grouped by abstract product. The collector is touched: Case1: if there no record in availability table and availability is created, it needs to be touched. Case 2: if availability amount was 0 and now it’s more than 0, it needs to be touched. Case 3: if availability amount was more than 0 and now it’s 0, it needs to be touched. Collected data example in JSON. { "abstractProductAvailability": true, "concreteProductAvailabilityItems": { "27003893-1": true, "27003893-2": true }
} This information is used on product details page whenAdd to cartbutton is rendered. Availability Calculation Product availability can have flagis_never_out_of_stock. This indicates that the product is always available for sale and does not have a finite stock. In this situation the availability calculation is not needed anymore. Availability = max(0, sum of all stock types(Stock) - Reserved Items) In state machine items get reserved for an open order. There are certain states that release item, for example when payment fails and order is canceled. But if order is successfully fulfilled and item is delivered, item stays reserved till the next stock update. Stock update triggers the eventstock update. For example in our dummy payment’s implementation this will move the items from “Shipped” state to next state. As the consecutive state is not reserved, the items that were already shipped, will not be reserved any more. Import / Change Stock It’s possible to usevendor/bin/console data:import:product-stockcommand to import stocks into database. The default stock importer usescsvfile fromsrc/Pyz/Zed/Updater/Business/Internal/data/import/product_stock.csvwhich imports stocks for demoshop. Administration Interface is provided to allow assigning stocks to products. This can be accessed at (zed.domain.tld)/availability. Stock update considers the stock from the stock file to be the absolute value. On stock update the stock is overwritten with the values from the file. If a certain product does not have a record in the stock file, then it is considered that the stock of this product does not have to be updated. Availability Per Store Since Availability module version 6.* we have added support for multi-store availability. That means that you can now have availability calculated per store basis. In the Administration Interface you can change from which store you want to see availability. The main change in Availability in thatspy_availabilityandspy_availability_abstractnow have foreign key to store table which indicates to which store it is applicable. Reservations in OMS have also undergone a few changes to support multiple multi-store scenarios. With Spryker shop, you can actually have several scenarios pertain to product warehouses in a multi-store environment. Each scenario is configured and enabled manually. The possible scenarios are listed below. Each store has own database and own warehouse. This means that stores have separate independent stocks and therefore separated product reservations and availability. Each store has own database, but warehouse is shared between the stores. This means that reservation and availabilities are synced.For the case when stores do not share database, but reservations must be shared, three new database tables have been created. spy_oms_product_reservation_store- this table will store reservation request from other stores. spy_oms_reservation_change_version- this table will store information about when last reservation occurred. spy_oms_reservation_last_exported_version- this table will store information about when reservations were exported to other stores last time. Also, we provide a few plugins to help implement synchronization: \Spryker\Zed\Oms\Communication\Plugin\Oms\ReservationHandler\ReservationVersionHandlerPlugin- this plugin will be called when customer makes an order and reservation is made. It will store reservation tospy_oms_reservation_change_versiondatabase table. This plugin should be registered in\Pyz\Zed\Oms\OmsDependencyProvider::getReservationHandlerPluginsplugin stack. \Spryker\Zed\Oms\Communication\Plugin\Oms\ReservationImport\ReservationExportPlugin- is the plugin which will be called when reservation export to other store is called. This plugin should decide if the export should be accepted. The delivery mechanism is not provided, it could be done with files or queue. For example, whenReservationExportPluginis called, you could write a file copy to other server and then read it there. Similar would be with queue "publish", then "consume" on other end. When reading export data on other store, you can then use\Spryker\Zed\Oms\Business\OmsFacadeInterface::importReservationwhich will store reservation information tospy_oms_product_reservation_storetable and update all timestamps accordingly. There is a console command to export all reservations:\Spryker\Zed\Oms\Communication\Console\ExportReservationConsole. It will trigger ReservationExportPlugin with reservations amounts to export. This command can be added to cronjob and run periodically. Database is shared between stores, but warehouses are separated by store. This means, that reservations and availability are separated per store and the warehouses (and their stocks) belong to specific stores. Assume there are DE and AT stores. DE store has Warehouse 1 and Warehouse 2, and AT has Warehouse 2. If user wants to buy some product from Warehouse 2 which is not available for AT store, but available in DE store, he/she would not be able to buy it in AT store (since the warehouses are separated), but could buy it in DE store (since the database is shared and it’s possible to switch between stores). When orders are placed, each reservation in spy_oms_product_reservationtable will also store information about store, the relationfk_store, tospy_store table. When adding a product to cart and displaying it there, the store identifierfk_storeis used to define the correct availability value for the specific store. From Availability module version 6.0 we have added a new configuration option to store.php file to have information about store with shared persistence. Add'sharedPersistenceWithStores' =&gt; []to stores.php, where array is store names, for example: 'storesWithSharedPersistence' =&gt; ['DE', 'AT'] $stores['DE'] = [ ... //other options 'storesWithSharedPersistence' =&gt; ['AT'] ] $stores['AT'] = [ ... //other options 'storesWithSharedPersistence' =&gt; ['DE'] ] That means that DE and AT both share database. This information will be used when updating OMS reservations. Database is shared between stores, warehouses are shared by the stores. In this case the reservation must be synchronized. When placing an order in Store A, the reservation is stored with the store identifierfk_store. An event is created and published in the queue, and synchronization with Store B happens.
See scenario 3 above for information about how reservations are handled as well learn about the new configuration option for shared database in store.php file. See also: Get a general idea of what inventory is and what differs product stock from availability Learn what the Stock module does Learn how to migrate to a newer version of Availability module Learn how to migrate to a newer version of OMS module Last review date: Feb. 26th, 2018</body>
</html>