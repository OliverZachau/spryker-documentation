<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Database Schema The ProductGroup(Undefined variable: General.bundle/module)providesspy_product_grouptable that stores product groups. Product group entities have only theid_product_groupfield, because we don’t need to display or refer to any groups in any way. The only necessary details for a group are the abstract products that are in the same group and order in which they have to be displayed. Thespy_product_abstract_grouptable stores exactly this information. https://www.gliffy.com/go/share/image/s365x3afydk5srvfsjs2.png?utm_medium=live-embed&amp;utm_source=custom Handling Product Groups With the KV Storage On Yves side the goal is to be able to read product group information fast without expensive calls to Zed and without a need to read from database. Therefore, the ProductGroup(Undefined variable: General.bundle/module)provides two Storage collectors that will store the necessary information in the KV Storage. ProductGroupCollectorStoragePlugin: Collects and stores the IDs of abstract products in the defined order for each product group. ProductAbstractGroupsCollectorStoragePlugin: Collects and stores the IDs of product groups for each abstract product. To read all abstract products that are in the same group(s) as a product that you would like to display, useProductGroupClient::findProductGroupItemsByIdProductAbstract()method. This returns an array of abstract products, read from the KV Storage. (Note that thespyProductGroupItems()twig function also uses this method to get the necessary information.) The algorithm of reading products by groups in details looks like the following: Read theproduct_abstract_groupsentry from KV Storage of the subject product to determine the group(s) it’s assigned to. Then for each group we get the ordered IDs of abstract products by reading the necessaryproduct_groupentries from the KV Storage. Merge the product IDs of all the groups of the subject product to one list. Since we don’t make difference between groups that a product is in, it makes sense to have one list with all its related items at the end. Change the order of the items by moving the subject product to the beginning of the list. Read product details from the KV Storage for all items in the list. As you can see the algorithm executes quite some commands to read from the KV Storage, but it’s still fast enough to get the necessary data to be able to display product groups on our frontend.</body>
</html>