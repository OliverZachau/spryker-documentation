<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>The touch tables are able create the snapshot of what’s currently loaded into the Yves data storages ( both key-value and search data storages) If a product was added into the Zed database after the last export, then there’s no corresponding entry in the touch table for that product. Once it’s exported, an entry is created. Each time the product is updated, an update is performed to that entry once the export task is running. Looking over the data inserted in the touch table we can say that every product has a lifecycle which is retrieved from the context. Possible statuses are: Status Condition new product does not exist in touch table onsale product is in touch table and ‘active=true’ paused product is in touch table and ‘active=false’ Product Glossary Abstract Product Represents all common characteristics of a single product offered as a number of variants Concrete Products (Variants) Represent only the characteristics that distinguish each variant PIM Product Information Management system Product Attributes Part of the Product Data that describes product characteristics Product Categories Categories group products with specific attribute sets Product Characteristics Properties of the product, such as color or size Product Variants Versions of the same product that differ one or more attributes, such as color and size Product Key Map Collector TheAttributeMapCollectoris responsible of exporting map of all possible super attribute permutations. This mapping information is required when displaying for example select component in Yves product detail page (can be any suitable UI component used), so with this map it’s possible to select correct combination. For example we have a product with two attributes, color and size. Product: Nike shoes withidProductConcrete = 1Attributes:Color: red, Size:43, Size: 42. For this product map will look like this. array( ( [color:red] =&gt; array( [size:43] =&gt; array( [id] =&gt; 1 ), [size:42] =&gt; array( [id] =&gt; 1 ) ), [size:43] =&gt; array( [color:red] =&gt; array( [id] =&gt; 1 ) ), [size:42] =&gt; array( [color:red] =&gt; array( [id] =&gt; 1 ) ) )
) The keycolor:redresembles to attribute key and value of attribute. Each leaf points to the concrete product (variant) id [id] =&gt; 1. The collector also has information about all available super attributes, and assigned concrete products ids. Only active products will be collected. Events Triggered There are a few events that are triggered by this(Undefined variable: General.bundle/module). You need to have the Event (Undefined variable: General.bundle/module)installed to be able to listen to them. Product.product_abstract.before.create- before abstract product persisted.ProductAbstractTransferpassed with data prepared for created new abstract product. Product.product_abstract.before.update- before abstract product updated.ProductAbstractTransferpassed with data prepared for product update. Product.product_concrete.before.create - before concrete product persisted.ProductConcreteTransferpassed with data prepared for created new concrete product. Product.product_concrete.before.update- before concrete product updated.ProductConcreteTransferpassed with data prepared for product update. Product.product_abstract.after.update- after abstract product updated.ProductAbstractTransferpassed. Product.product_abstract.after.create- after abstract product created.ProductAbstractTransferpassed. Product.product_concrete.after.create- after concrete product created.ProductConcreteTransferpassed. Product.product_concrete.after.update- after concrete product updated.ProductConcreteTransferpassed. Product.product_abstract.read- when abstract product read from persistence, could be used to populateProductAbstractTransferwith additional data. Product.product_concrete.read- when concrete product read from persistence, could be used to populateProductConcreteTransferwith additional data.</body>
</html>