<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Entry Step Redirect customer to correct step based on QuoteTransfer state. This step requiresinput = falseso it won’t be rendered. Customer Step The customer step provides three forms (login, register and register as a guest). This step is responsible for fillingCustomerTransferwith corresponding data. The authentication logic is left to customer(Undefined variable: General.bundle/module), this step is only delegating calls to (and from) customer(Undefined variable: General.bundle/module)and mapping data with forms. Address Step The address step where customer fills billing and shipping addresses inQuoteTransfer::billingandQuoteTransfer::shippingrespectively. This step lets the returning customers to select one of the existing addresses or create a new one. New and guest customers can only create a new address. If a new address is selected, then it’s only created when order is placed inOrderCustomerSavePlugin. This step will be skipped if already signed in customer uses checkout. Shipment Step Get shipment method information and store it into the quote. This step requires additional configuration because different shipment providers and different ways forms should be handled for each. Form Handling: ShipmentFormuses subforms, each subform is implemented as a plugin that implementsCheckoutSubFormInterfaceand is provided inCheckoutFactory::createShipmentMethodsSubForms()Main form uses quote transfer as data store. Data for shipment is stored underQuoteTransfer::shipmentas aShipmentTransferobject. ShipmentTransfercontains: shipmentSelection (string) — name of the form for the selected shipment. carrier (ShipmentCarrierTransfer) — method (ShipmentMethodTransfer) — information about the shipment method that is currently selected. Data Handling: Data handling happens after a valid form is being submitted during theShipmentStep; step receives plugins that implementCheckoutStepHandlerPluginInterfaceand provided inCheckoutFactory::createShipmentPlugins(). Whenexecute()method is called onShipmentStepthen the plugin that is identified by theShipmentTransfer::shipmentSelectionstring is selected and methodCheckoutStepHandlerPluginInterface::addToQuote()is called to update `QuoteTransfer with payment data. From this part the data handling is left to concrete CheckoutStepHandler. The approach of implementing shipment and payment handlers and forms are the same PaymentStep Payment Step Get payment information and store it into quote for later processing when state machine is triggered. Payment step has similar structure and data handling mechanics as the shipment step does. Form Handling: PaymentFormuses subforms, each subform is implemented as a plugin that implementsCheckoutSubFormPluginInterfaceand is provided in theCheckoutFactory::createPaymentMethodSubForms(). Main form usesQuoteTransferas a data store. Data for payment is stored underQuoteTransfer::paymentas aPaymentTransfer` object. Main form has radio buttons, where the customer can select from the available payment methods. Choices are built from the subform name. Each provided subform corresponds to a radio input. When the form is created it requires the property path to be provided so that it knows how to map it’s subform toQuoteTransfer. see property_path . Property path is built out of few parts ofPaymentTransfer::paymentand subform providesgetPropertyPath()that returns a string; this string should return the property that exists underPaymentTransfer. PaymentTransferincludes: paymentProvider (string) — payment provider name (Paypal, Payolution etc..). paymentMethod (string) — payment method (credit card, invoice). paymentSelection (string) — subform name that is currently selected. Data handling: Data handling happens after a valid form is submitted during thePaymentStep; the step receives plugins that implementCheckoutStepHandlerPluginInterfaceand that are provided in theCheckoutFactory::createPaymentPlugins(). Whenexecute()method is called onPaymentStep, the plugin that is identified byPaymentTransfer::paymentSelectionstring is selected and theCheckoutStepHandlerPluginInterface::addToQuote()is called to update `QuoteTransfer with payment data. From this part all population or data handling is left to concrete CheckoutStepHandler. Example: a new payment methodPaypalmust be added. First step would be to add the new property toPaymentTransferand call itpaypal. This property will usePaypalTransferand it will contain the data we need to map the details from the form. Next create/use Paypal(Undefined variable: General.bundle/module)to add step plugin. In the Paypal(Undefined variable: General.bundle/module)add the following plugins: CreatePaypalCheckoutSubFormimplementingCheckoutSubFormPluginInterfacethat returns a subform that implementsSubFormInterface CreatePaypalHandlerimplementingCheckoutStepHandlerPluginInterfacethat should populateQuoteTransfer:payment:paypalwithPaypalTransfer After creation you need to add the plugins to the checkout process; to do this you need to create aCheckoutDependencyInjectorinside your(Undefined variable: General.bundle/module)and configure it to be used by the Checkout(Undefined variable: General.bundle/module). From there you can simply inject the needed forms and handler. Add your form to theCheckoutSubFormPluginCollectionby extending the givenCheckoutDependencyProvider::PAYMENT_SUB_FORMS Your handler needs to be added to theCheckoutStepHandlerPluginCollectionby extending the givenCheckoutDependencyProvider::PAYMENT_METHOD_HANDLER After this, you should be able to see the new payment selection with subform rendered below. Summary Step Display order information about to be placed, item details and order totals. Place Order Step Place order into system. This step requiresinput = false. This step makes Zed HTTP request which sendsQuoteTransfer. In this step all order saving is happening. Success Page Display success page, on executing, clearsQuoteTransfer, also customer session is marked as dirty so that with next request it would reload with updated data (new customer address).</body>
</html>