<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>The Collector module provides mechanisms to manage data consumed by front-end application. To populate the data stores, 4 steps are required: Touch Configure Collect Touch In order for anything to be synchronized, first it has to be marked (touched) via theTouch mechanism. Each collector uses this mechanism to be able to determine which data should be added, updated or deleted. Cascading Updates, depending on the type of data changed, can trigger cascade update of multiple resources. For example: renaming of a category will result in updating the urls, category nodes, navigation and products. The basic idea is that, any resource which should be exported, has an entry in thespy_touchtable. This table is used by collector’s query, to collect items marked for synchronization. SeeTouchfor more information. Touch Record CollectorQueries must read information fromspy_touchtable in order to determine which resources should be collected. Depending on Collector Store Type, thespy_touch_storageorspy_touch_searchtable records are also needed. These records are used to determine the keys of the resources that are exported to client-side data stores, and this combined information represents theTouch Record. SQL Touch Record Implementation To write a collector SQL query, you must include the following 3 columns: id_touch from the spy_touch table item_id from the spy_touch table id either from the spy_touch_storage or the spy_touch_search, depending on the case. Storage: ... spy_touch.id_touch AS %s, spy_touch.item_id AS %s, spy_touch_storage.id_touch_storage AS %s, ... INNER JOIN spy_touch t ON (tree.id_category_node = t.item_id AND t.item_type = :itemType) LEFT JOIN spy_touch_storage ON spy_touch_storage.fk_touch = t.id_touch AND spy_touch_storage.fk_locale = :fk_locale Search: ... spy_touch.id_touch AS %s, spy_touch.item_id AS %s, spy_touch_search.id_touch_search AS %s, ... INNER JOIN spy_touch t ON (tree.id_category_node = t.item_id AND t.item_type = :itemType) LEFT JOIN spy_touch_search ON spy_touch_search.fk_touch = t.id_touch AND spy_touch_search.fk_locale = :fk_locale :itemTypeis the collectorType and:fk_localeisidLocalefromspy_localetable. Each placeholder (%s) for the Touch columns will be replaced by values that are defined in theCollectorConfig. CheckprepareCollectorScope()methods for implementation details. Propel Touch Record Implementation For Propel type collector query those steps are not required, as the information about Touch Record is already integrated. Configure The collectors register through plugins. When adding a new collector, you must create a dedicated plugin for it in theCommunicationlayer, under thePlugin/folder. The plugin for the new collector must extendAbstractCollectorPluginclass and must implement therun()method which calls the correspondingCollectorFacadethat calls the associated collector. &lt;?php
/** * @param \Orm\Zed\Touch\Persistence\SpyTouchQuery $baseQuery * @param \Generated\Shared\Transfer\LocaleTransfer $locale * @param \Spryker\Zed\Collector\Business\Model\BatchResultInterface $result * @param \Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface $dataWriter * @param \Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface $touchUpdater * @param \Symfony\Component\Console\Output\OutputInterface $output * * @return void */
abstract public function run( SpyTouchQuery $baseQuery, LocaleTransfer $locale, BatchResultInterface $result, WriterInterface $dataWriter, TouchUpdaterInterface $touchUpdater, OutputInterface $output
);
?&gt; Example:NavigationCollectorStoragePlugin. &lt;?php
namespace Pyz\Zed\Collector\Communication\Plugin; use Generated\Shared\Transfer\LocaleTransfer;
use Orm\Zed\Touch\Persistence\SpyTouchQuery;
use Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface;
use Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface;
use Spryker\Zed\Collector\Business\Model\BatchResultInterface;
use Spryker\Zed\Collector\Communication\Plugin\AbstractCollectorPlugin;
use Symfony\Component\Console\Output\OutputInterface; /** * @method \Pyz\Zed\Collector\Communication\CollectorCommunicationFactory getFactory() * @method \Pyz\Zed\Collector\Business\CollectorFacade getFacade() */
class NavigationCollectorStoragePlugin extends AbstractCollectorPlugin
{ /** * @param \Orm\Zed\Touch\Persistence\SpyTouchQuery $baseQuery * @param \Generated\Shared\Transfer\LocaleTransfer $locale * @param \Spryker\Zed\Collector\Business\Model\BatchResultInterface $result * @param \Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface $dataWriter * @param \Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface $touchUpdater * @param \Symfony\Component\Console\Output\OutputInterface $output * * @return void */ public function run( SpyTouchQuery $baseQuery, LocaleTransfer $locale, BatchResultInterface $result, WriterInterface $dataWriter, TouchUpdaterInterface $touchUpdater, OutputInterface $output ) { $this-&gt;getFacade() -&gt;runStorageNavigationCollector($baseQuery, $locale, $result, $dataWriter, $touchUpdater, $output); } }
?&gt; Of course, for each collector a dedicated method must be defined in the CollectorFacade, that makes the connection between the collector plugin and the collector. &lt;?php
/** * @param \Orm\Zed\Touch\Persistence\SpyTouchQuery $baseQuery * @param \Generated\Shared\Transfer\LocaleTransfer $locale * @param \Spryker\Zed\Collector\Business\Model\BatchResultInterface $result * @param \Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface $dataWriter * @param \Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface $touchUpdater * * @return void */
public function runStorageNavigationCollector( SpyTouchQuery $baseQuery, LocaleTransfer $locale, BatchResultInterface $result, WriterInterface $dataWriter, TouchUpdaterInterface $touchUpdater, OutputInterface $output
) { $this-&gt;getFactory() -&gt;createStorageNavigationCollector() -&gt;run($baseQuery, $locale, $result, $dataWriter, $touchUpdater, $output);
}
?&gt; The collectors are registered in the application through their corresponding plugins in theCollectorDependencyProviderclass. the collectors that gather data for search type store are registered underSEARCH_PLUGINS the collectors that gather data for the storage type store are registered underSTORAGE_PLUGINS &lt;?php
$container[static::SEARCH_PLUGINS] = function (Container $container) { return [ 'product_abstract' =&gt; new ProductCollectorSearchPlugin(), ];
}; $container[static::STORAGE_PLUGINS] = function (Container $container) { return [ 'product_abstract' =&gt; new ProductCollectorStoragePlugin(), 'categorynode' =&gt; new CategoryNodeCollectorStoragePlugin(), 'navigation' =&gt; new NavigationCollectorStoragePlugin(), 'translation' =&gt; new TranslationCollectorStoragePlugin(), 'page' =&gt; new PageCollectorStoragePlugin(), 'block' =&gt; new BlockCollectorStoragePlugin(), 'redirect' =&gt; new RedirectCollectorStoragePlugin(), 'url' =&gt; new UrlCollectorStoragePlugin(), ];
};
?&gt; Collect Data collection is done in 2 steps: Querying/fetching data from the SQL database (Persistence layer) Aggregating/processing data (Business layer) Query To fetch data from the database, you can either use aPropelorPDOtype query, under the Persistence layer. AbstractPdoCollectorQuery- uses nativeSQL AbstractPropelCollectorQuery- usesPropel Query AbstractPdoCollectorQuery AbstractCollectorQuerycontains one abstract methodprepareQuery(). &lt;?php
/** * @return void */
abstract protected function prepareQuery();
?&gt; You can set your own SQL query withsql()method ofCriteriaBuilderinterface. &lt;?php
/** * @param string $sqlTemplate * * @return $this */
public function sql($sqlTemplate);
?&gt; Example of theNavigationCollectorquery, that uses nativePostgreSQLto retrieve hierarchical navigation data. Example of theNavigationCollectorquery, that uses nativePostgreSQLto retrieve hierarchical navigation data. &lt;?php
namespace Pyz\Zed\Collector\Persistence\Storage\Pdo\PostgreSql; use Spryker\Zed\Collector\Persistence\Exporter\AbstractPdoCollectorQuery; class NavigationCollectorQuery extends AbstractPdoCollectorQuery
{ /** * @return void */ protected function prepareQuery() { $sql = '
WITH RECURSIVE tree AS ( SELECT n.id_category_node, n.fk_parent_category_node, n.fk_category, n.node_order FROM spy_category_node n INNER JOIN spy_category c ON c.id_category = n.fk_category AND c.is_active = TRUE AND c.is_in_menu = TRUE INNER JOIN spy_touch t ON ( n.id_category_node = t.item_id AND t.item_event = :spy_touch_item_event AND t.touched &gt;= :spy_touch_touched AND t.item_type = :spy_touch_item_type ) WHERE n.is_root = TRUE UNION SELECT n.id_category_node, n.fk_parent_category_node, n.fk_category, n.node_order FROM tree INNER JOIN spy_category_node n ON n.fk_parent_category_node = tree.id_category_node INNER JOIN spy_category c ON c.id_category = n.fk_category AND c.is_active = TRUE AND c.is_in_menu = TRUE )
SELECT t.id_touch AS %s, t.item_id AS %s, spy_touch_storage.id_touch_storage AS %s, tree.*, u.url, ca.name, ca.meta_title, ca.meta_description, ca.meta_keywords, ca.category_image_name
FROM tree INNER JOIN spy_url u ON (u.fk_resource_categorynode = tree.id_category_node AND u.fk_locale = :fk_locale_1) INNER JOIN spy_category_attribute ca ON (ca.fk_category = tree.fk_category AND ca.fk_locale = :fk_locale_2) INNER JOIN spy_touch t ON (tree.id_category_node = t.item_id AND t.item_type = :itemType) LEFT JOIN spy_touch_storage ON spy_touch_storage.fk_touch = t.id_touch AND spy_touch_storage.fk_locale = :fk_locale_3
'; $this-&gt;criteriaBuilder -&gt;sql($sql) -&gt;setOrderBy([ 'tree.fk_parent_category_node' =&gt; 'ASC', 'tree.node_order' =&gt; 'DESC', ]) -&gt;setParameter('itemType', 'categorynode') -&gt;setParameter('fk_locale_1', $this-&gt;locale-&gt;getIdLocale()) -&gt;setParameter('fk_locale_2', $this-&gt;locale-&gt;getIdLocale()) -&gt;setParameter('fk_locale_3', $this-&gt;locale-&gt;getIdLocale()); } } ?&gt; CriteriaBuilder The collector will use conditions generated byCriteriaBuilderto create data set for synchronization. CriteriaBuilder provides an interface that that makes sure all the parameters and their values are properly bind, or if the order and limit a properly setup, and if they are in the right place in SQL query. AbstractPropelCollectorQuery Implementation ofAbstractCollectorQueryis fairly simple, as it has only one abstract methodprepareQuery(). &lt;?php
/** * @return void */
abstract protected function prepareQuery();
?&gt; You define your criteria withtouchQueryinterface, usingPropel Query. Example ofBlockCollectorquery, which usesPropel Queryto retrieve CMS blocks data. Example of aBlockCollectorquery, using aPropel Queryto retrieve CMS blocks data. &lt;?php
namespace Pyz\Zed\Collector\Persistence\Storage\Propel; use Orm\Zed\Cms\Persistence\Map\SpyCmsBlockTableMap;
use Orm\Zed\Cms\Persistence\Map\SpyCmsGlossaryKeyMappingTableMap;
use Orm\Zed\Cms\Persistence\Map\SpyCmsPageTableMap;
use Orm\Zed\Cms\Persistence\Map\SpyCmsTemplateTableMap;
use Orm\Zed\Glossary\Persistence\Map\SpyGlossaryKeyTableMap;
use Orm\Zed\Touch\Persistence\Map\SpyTouchTableMap;
use Orm\Zed\Url\Persistence\Map\SpyUrlTableMap;
use Propel\Runtime\ActiveQuery\Criteria;
use Spryker\Zed\Collector\Persistence\Exporter\AbstractPropelCollectorQuery; class BlockCollectorQuery extends AbstractPropelCollectorQuery
{ /** * @return void */ protected function prepareQuery() { $this-&gt;touchQuery-&gt;addJoin( SpyTouchTableMap::COL_ITEM_ID, SpyCmsBlockTableMap::COL_ID_CMS_BLOCK, Criteria::INNER_JOIN ); $this-&gt;touchQuery-&gt;addJoin( SpyCmsBlockTableMap::COL_FK_PAGE, SpyCmsPageTableMap::COL_ID_CMS_PAGE, Criteria::INNER_JOIN ); $this-&gt;touchQuery-&gt;addJoin( SpyCmsPageTableMap::COL_ID_CMS_PAGE, SpyCmsGlossaryKeyMappingTableMap::COL_FK_PAGE, Criteria::INNER_JOIN ); $this-&gt;touchQuery-&gt;addJoin( SpyCmsPageTableMap::COL_FK_TEMPLATE, SpyCmsTemplateTableMap::COL_ID_CMS_TEMPLATE, Criteria::INNER_JOIN ); $this-&gt;touchQuery-&gt;addJoin( SpyCmsGlossaryKeyMappingTableMap::COL_FK_GLOSSARY_KEY, SpyGlossaryKeyTableMap::COL_ID_GLOSSARY_KEY, Criteria::INNER_JOIN ); $this-&gt;touchQuery-&gt;addAnd( SpyUrlTableMap::COL_FK_LOCALE, $this-&gt;getLocale()-&gt;getIdLocale(), Criteria::EQUAL ); $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_ID_CMS_BLOCK, 'block_id'); $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_NAME, 'block_name'); $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_TYPE, 'block_type'); $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_VALUE, 'block_value'); $this-&gt;touchQuery-&gt;withColumn(SpyCmsGlossaryKeyMappingTableMap::COL_PLACEHOLDER, 'placeholder'); $this-&gt;touchQuery-&gt;withColumn(SpyCmsTemplateTableMap::COL_TEMPLATE_PATH, 'template_path'); $this-&gt;touchQuery-&gt;withColumn(SpyCmsPageTableMap::COL_IS_ACTIVE, 'isActive'); $this-&gt;touchQuery-&gt;withColumn(SpyGlossaryKeyTableMap::COL_KEY, 'translation_key'); } } ?&gt; Process There are four collector types, grouped by store and query type they use. Storage Collectors AbstractStoragePdoCollector- usesPDOtype query AbstractStoragePropelCollector- usesPropeltype query The entities processed by those collectors will be synchronized with Storage type data store. Search Collectors AbstractSearchPdoCollector- usesPDOtype query AbstractSearchPropelCollector- usesPropeltype query The entities processed by those collectors will be synchronized with Search type data store. After fetching data from thePersistencelayer, and processing in Buissiness layer, it is saved under theTouchKeyin the data store. ATouchKeyis any unique string that can be used to identify resources in the stores. There are two abstract methods, which every collector has to implement. &lt;?php
/** * @param string $touchKey * @param array $collectItemData * * @return array */
abstract protected function collectItem($touchKey, array $collectItemData); /** * @return string */
abstract protected function collectResourceType();
?&gt; The string returned bycollectResourceType()is used to generate theTouchKey. ThecollectItem()method decides which data is saved under theTouchKeyin the store. Example of aRedirectCollectorclass, which uses Storage type data store. &lt;?php
namespace Pyz\Zed\Collector\Business\Storage; use Spryker\Zed\Collector\Business\Collector\Storage\AbstractStoragePropelCollector;
use Spryker\Zed\Url\UrlConfig; class RedirectCollector extends AbstractStoragePropelCollector
{ /** * @return string */ protected function collectResourceType() { return 'redirect'; } /** * @param string $touchKey * @param array $collectItemData * * @return array */ protected function collectItem($touchKey, array $collectItemData) { return [ 'from_url' =&gt; $collectItemData['from_url'], 'to_url' =&gt; $collectItemData['to_url'], 'status' =&gt; $collectItemData['status'], 'id' =&gt; $collectItemData['id'], ]; } }
?&gt; The output of this collector will produce aredirecttype entity, stored underkv:de.de_de.resource.redirect.1key, with the following content: { "from_url": "/imp", "to_url": "/impressum", "status": 303, "id": 1
} The content of$collectItemDataarray represents one row from the result set, generated by the collector’s query in Persistence layer.</body>
</html>