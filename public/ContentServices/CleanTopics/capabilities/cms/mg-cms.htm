<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Upgrading from Version 4.* to Version 5.* CMS version 5.0 is responsible only for CMS pages and page versioning. CMS Block functionality became more flexible and moved to CmsBlock module . If you used CMS Blocks before, you need to migrate your data to the new structure. If you did not use CMS Blocks in your project, you can skip the migration process. The migration process for CMS Block data is as follows: Install CMS Block module To install the module"spryker/cms-block": "^1.0.0"with Composer is required. Perform database migration `vendor/bin/console propel:diff`, also manual review is necessary for the generated migration file `vendor/bin/console propel:migrate` `vendor/bin/console propel:model:build` After running the last command you’ll find some new classes in your project under\Orm\Zed\Cms\Persistencenamespace. It’s important to make sure that they are extending the base classes from the core, i.e.`Orm\Zed\Cms\Persistence\SpyCmsBlockextendsSpryker\Zed\CmsBlock\Persistence\Propel\AbstractSpyCmsBlock``Orm\Zed\Cms\Persistence\SpyCmsBlockQueryextendsSpryker\Zed\CmsBlock\Persistence\Propel\AbstractSpyCmsBlockQuery.` The same is forSpyCmsBlockGlossaryKeyMapping,SpyCmsBlockGlossaryKeyMappingQuery,SpyCmsBlockTemplate,SpyCmsBlockTemplateQuery. Move templates Now your block and page templates can be found insrc/Pyz/Yves/Cms/Theme/default/template/*orsrc/Pyz/Shared/Cms/Theme/default/template/*folders. Move CMS Block templates tosrc/Pyz/Shared/CmsBlock/Theme/default/template/*folder. Run migration script For quick and smooth migration we have prepared a migration script. You can find it below. Click here to expand the code sample &lt;?php /** * Copyright © 2016-present Spryker Systems GmbH. All rights reserved. * Use of this software requires acceptance of the Evaluation License Agreement. See LICENSE file. */ namespace Pyz\Zed\CmsBlock\Communication\Console; use Orm\Zed\Cms\Persistence\SpyCmsPage;
use Orm\Zed\Cms\Persistence\SpyCmsPageQuery;
use Orm\Zed\Cms\Persistence\SpyCmsTemplate;
use Orm\Zed\CmsBlock\Persistence\SpyCmsBlock;
use Orm\Zed\CmsBlock\Persistence\SpyCmsBlockGlossaryKeyMapping;
use Orm\Zed\CmsBlock\Persistence\SpyCmsBlockGlossaryKeyMappingQuery;
use Orm\Zed\CmsBlock\Persistence\SpyCmsBlockQuery;
use Orm\Zed\CmsBlock\Persistence\SpyCmsBlockTemplate;
use Orm\Zed\CmsBlock\Persistence\SpyCmsBlockTemplateQuery;
use Orm\Zed\CmsBlockCategoryConnector\Persistence\SpyCmsBlockCategoryConnector;
use Propel\Runtime\ActiveQuery\Criteria;
use Propel\Runtime\Propel;
use Spryker\Zed\Kernel\Communication\Console\Console;
use Spryker\Zed\Kernel\Locator;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface; /** * @method \Spryker\Zed\CmsBlock\Communication\CmsBlockCommunicationFactory getFactory() * @method \Spryker\Zed\CmsBlock\Business\CmsBlockFacade getFacade() */
class CmsToCmsBlockDataMigration extends Console
{ const COMMAND_NAME = 'cms-cms-block:migrate'; const COMMAND_DESCRIPTION = 'Migrates CMS Block data from CMS module'; const COMMAND_ARGUMENT_DRY_RUN = 'dry-run'; const CMS_BLOCK_RELATION_TYPE_CATEGORY = 'category'; /** * @param InputInterface $input * @param OutputInterface $output * * @return void */ public function execute(InputInterface $input, OutputInterface $output) { $connection = Propel::getConnection(); $spyCmsBlocks = SpyCmsBlockQuery::create() -&gt;filterByFkPage(null, Criteria::ISNOTNULL) -&gt;filterByFkTemplate(null, Criteria::ISNULL) -&gt;find(); $spyCmsBlocksCount = count($spyCmsBlocks); $output-&gt;writeln(sprintf('Processing %s blocks...', $spyCmsBlocksCount)); foreach ($spyCmsBlocks as $spyCmsBlock) { $spyCmsPage = SpyCmsPageQuery::create() -&gt;filterByIdCmsPage($spyCmsBlock-&gt;getFkPage()) -&gt;findOne(); try { $connection-&gt;beginTransaction(); //Migration of template $spyCmsTemplate = $spyCmsPage-&gt;getCmsTemplate(); $spyCmsBlockTemplate = $this-&gt;createCmsBlockTemplate($spyCmsTemplate); $spyCmsBlock-&gt;setFkTemplate($spyCmsBlockTemplate-&gt;getIdCmsBlockTemplate()); //Migration of common data fields $spyCmsBlock-&gt;setValidFrom($spyCmsPage-&gt;getValidFrom()); $spyCmsBlock-&gt;setValidTo($spyCmsPage-&gt;getValidTo()); $spyCmsBlock-&gt;setIsActive($spyCmsPage-&gt;getIsActive()); //Migration of category relation if ($spyCmsBlock-&gt;getType() === self::CMS_BLOCK_RELATION_TYPE_CATEGORY) { if (!$this-&gt;isCategoryConnectorInstalled()) { $output-&gt;writeln('To import relation to Category you need to install CmsBlockCategoryConnector module'); $connection-&gt;rollBack(); continue; } $this-&gt;createCmsBlockCategoryConnector($spyCmsBlock); } $spyCmsBlock-&gt;save(); $this-&gt;migrateGlossary($spyCmsPage, $spyCmsBlock); $connection-&gt;commit(); } catch (\Exception $exception) { $output-&gt;writeln('ERROR: ' . $exception-&gt;getMessage()); $connection-&gt;rollBack(); } } $output-&gt;writeln('Successfully finished.'); } /** * @param \Orm\Zed\Cms\Persistence\SpyCmsTemplate $spyCmsTemplate * * @return \Orm\Zed\CmsBlock\Persistence\SpyCmsBlockTemplate */ protected function createCmsBlockTemplate(SpyCmsTemplate $spyCmsTemplate) { $spyCmsBlockTemplate = SpyCmsBlockTemplateQuery::create() -&gt;filterByTemplatePath($spyCmsTemplate-&gt;getTemplatePath()) -&gt;findOne(); if (empty($spyCmsBlockTemplate)) { $spyCmsBlockTemplate = new SpyCmsBlockTemplate(); $spyCmsBlockTemplate-&gt;setTemplateName($spyCmsTemplate-&gt;getTemplateName()); $spyCmsBlockTemplate-&gt;setTemplatePath($spyCmsTemplate-&gt;getTemplatePath()); $spyCmsBlockTemplate-&gt;save(); } return $spyCmsBlockTemplate; } /** * @param SpyCmsBlock $spyCmsBlock * * @return SpyCmsBlockCategoryConnector */ protected function createCmsBlockCategoryConnector(SpyCmsBlock $spyCmsBlock) { $spyCmsBlockRelation = new SpyCmsBlockCategoryConnector(); $spyCmsBlockRelation-&gt;setFkCmsBlock($spyCmsBlock-&gt;getIdCmsBlock()); $spyCmsBlockRelation-&gt;setFkCategory($spyCmsBlock-&gt;getValue()); $spyCmsBlockRelation-&gt;save(); return $spyCmsBlockRelation; } /** * @param SpyCmsPage $spyCmsPage * @param SpyCmsBlock $spyCmsBlock * * @return void */ protected function migrateGlossary(SpyCmsPage $spyCmsPage, SpyCmsBlock $spyCmsBlock) { foreach ($spyCmsPage-&gt;getSpyCmsGlossaryKeyMappings() as $cmsGlossaryKeyMapping) { $exists = SpyCmsBlockGlossaryKeyMappingQuery::create() -&gt;filterByFkCmsBlock($spyCmsBlock-&gt;getIdCmsBlock()) -&gt;filterByPlaceholder($cmsGlossaryKeyMapping-&gt;getPlaceholder()) -&gt;exists(); if (!$exists) { $spyCmsBlockGlossaryKeyMapping = new SpyCmsBlockGlossaryKeyMapping(); $spyCmsBlockGlossaryKeyMapping-&gt;setFkCmsBlock($spyCmsBlock-&gt;getIdCmsBlock()); $spyCmsBlockGlossaryKeyMapping-&gt;setFkGlossaryKey($cmsGlossaryKeyMapping-&gt;getFkGlossaryKey()); $spyCmsBlockGlossaryKeyMapping-&gt;setPlaceholder($cmsGlossaryKeyMapping-&gt;getPlaceholder()); $spyCmsBlockGlossaryKeyMapping-&gt;save(); } } } /** * @return void */ protected function configure() { parent::configure(); $this-&gt;setName(static::COMMAND_NAME); $this-&gt;setDescription(static::COMMAND_DESCRIPTION); $this-&gt;addOption( static::COMMAND_ARGUMENT_DRY_RUN, null, InputOption::VALUE_REQUIRED, 'Run without database changes' ); } /** * @return bool */ protected function isCategoryConnectorInstalled() { return class_exists(SpyCmsBlockCategoryConnector::class); } } Copy script tosrc/Pyz/Zed/CmsBlock/Communication/Console/CmsToCmsBlockDataMigration.phpand register it inPyz\Zed\Console\ConsoleDependencyProvider. &lt;?php
namespace Pyz\Zed\Console; class ConsoleDependencyProvider extends SprykerConsoleDependencyProvider
{ public function getConsoleCommands(Container $container) { $commands = [ ... CmsToCmsBlockDataMigration() ]; ... }
} Run the script with the commandvendor/bin/console cms-cms-block:migrate. Upgrading from Version 3.* to Version 4.* CMS Version 5.0 has a new concept for showing pages in the frontend. In previous CMS versions, after creating a CMS page and running the collectors, we were able to see the page in the frontend, but now this has changed. After creating a cms page, another step calledPublishis needed to display the page in the frontend. Publish aggregates all CMS related data and puts it to our new CMS tablespy_cms_version. The new collectors push this data to the frontend storage and search. Before upgrading, make sure that you do not use any deprecated code from version 3|4.*. Check the description of the deprecated code (inside the code) to see what you will need to use instead. Database Migration To start Dabase migration, run the following commands: vendor/bin/console propel:diff, manual review is necessary for the generated migration file. vendor/bin/console propel:migrate vendor/bin/console propel:model:build After running the last command, you will find some new classes in your project under the\Orm\Zed\Cms\Persistencenamespace. It is important to make sure that they are extending the base classes from the core, i.e. Orm\Zed\Cms\Persistence\SpyCmsVersionextendsSpryker\Zed\Cms\Persistence\Propel\SpyCmsVersion, Orm\Zed\Cms\Persistence\SpyCmsVersionQueryextendsSpryker\Zed\Cms\Persistence\Propel\SpyCmsVersionQuery CMS Templates In this version we have moved all CMS templates to theSharedlayer instead of onlyYves, but you are still able to use the old files. src/Pyz/Yves/Cms/Theme/default/template/*=&gt;src/Pyz/Shared/Cms/Theme/default/template/* CMS Twig Functions TheTwigCmsfunction has been improved to provide better speed and performance, it will only send query to Redis when the translations are not available. You can still work with the current version although upgrading is highly recommended. You can find it here:src/Pyz/Yves/Cms/Plugin/TwigCms.php CMS Collector To push new CMS version data to the frontend storage and search, add it tosrc/Pyz/Zed/Collector/CollectorDependencyProvider.phpplugin stack: Click to expand the code sample &lt;?php ... use Spryker\Zed\CmsCollector\Communication\Plugin\CmsVersionPageCollectorSearchPlugin; use Spryker\Zed\CmsCollector\Communication\Plugin\CmsVersionPageCollectorStoragePlugin; class CollectorDependencyProvider extends SprykerCollectorDependencyProvider { ... $container[self::SEARCH_PLUGINS] = function (Container $container) { return [ ... CmsConstants::RESOURCE_TYPE_PAGE =&gt; new CmsVersionPageCollectorSearchPlugin(), ]; }; ... $container[self::STORAGE_PLUGINS] = function (Container $container) { return [ ... CmsConstants::RESOURCE_TYPE_PAGE =&gt; new CmsVersionPageCollectorStoragePlugin(), ... ]; }; ... ?&gt; CMS User Interaction When a CMS page is published, we also store/show user information for this action. To store and show user information, register two new plugins from the newCmsUserConnectormodule. Add them here:src/Pyz/Zed/Cms/CmsDependencyProvider.php Click to expand the code sample &lt;?php
namespace Pyz\Zed\Cms; use Spryker\Zed\Cms\CmsDependencyProvider as SprykerCmsDependencyProvider;
use Spryker\Zed\CmsUserConnector\Communication\Plugin\UserCmsVersionPostSavePlugin;
use Spryker\Zed\CmsUserConnector\Communication\Plugin\UserCmsVersionTransferExpanderPlugin;
use Spryker\Zed\Kernel\Container; class CmsDependencyProvider extends SprykerCmsDependencyProvider
{ protected function getPostSavePlugins(Container $container) { return [ new UserCmsVersionPostSavePlugin() ]; } protected function getTransferExpanderPlugins(Container $container) { return [ new UserCmsVersionTransferExpanderPlugin() ]; }
}
?&gt; CMS Data Importer To publish pages after importing, add this into your CMS Importer class: Click to expand the code sample &lt;?php /** * @param array $data * * @return void */ protected function importOne(array $data) { $page = $this-&gt;format($data); $templateTransfer = $this-&gt;findOrCreateTemplate($page[self::TEMPLATE]); $pageTransfer = $this-&gt;createPage($templateTransfer, $page); foreach ($this-&gt;localeFacade-&gt;getLocaleCollection() as $locale =&gt; $localeTransfer) { $urlTransfer = new UrlTransfer(); $urlTransfer-&gt;setUrl($page[self::LOCALES][$locale][self::URL]); if ($this-&gt;urlFacade-&gt;hasUrl($urlTransfer)) { return; } $placeholders = $page[self::LOCALES][$locale][self::PLACEHOLDERS]; $this-&gt;createPageUrl($pageTransfer, $urlTransfer-&gt;getUrl(), $localeTransfer); $this-&gt;createPlaceholder($placeholders, $pageTransfer, $localeTransfer); } $this-&gt;cmsFacade-&gt;publishWithVersion($pageTransfer-&gt;getIdCmsPage()); // Publishing the pages } ?&gt; Publishing Current Pages To publish current pages, create a console command that calls the following method: &lt;?php protected function publishAllPages() { $spyCmsPagesEntities = SpyCmsPageQuery::create()-&gt;find(); foreach ($spyCmsPagesEntities as $spyCmsPagesEntity) { $this-&gt;cmsFacade-&gt;publishWithVersion($spyCmsPagesEntity-&gt;getIdCmsPage()); } ?&gt; Upgrading from Version 2.* to Version 3.* We have extended CMS pages with localized attributes such as name and HTML meta header information. Also CMS pages can now be marked as searchable. These changes required some changes in the database. Before upgrading to the new version, make sure that you do not use any deprecated code from version 2.*. Check the description of the deprecated code to see what you will need to use instead. Database migration vendor/bin/console propel:diff, also manual review is necessary for the generated migration file. vendor/bin/console propel:migrate vendor/bin/console propel:model:build After running the last command you’ll find some new classes in your project under\Orm\Zed\Cms\Persistencenamespace. It’s important to make sure that they are extending the base classes from the core, i.e. Orm\Zed\Cms\Persistence\SpyCmsPageLocalizedAttributes extends Spryker\Zed\Cms\Persistence\Propel\AbstractSpyCmsPageLocalizedAttributes, Orm\Zed\Cms\Persistence\SpyCmsPageLocalizedAttributesQueryextendsSpryker\Zed\Cms\Persistence\Propel\AbstractSpyCmsPageLocalizedAttributesQuery. See also: Learn how to use CMS Learn how to migrate CMS Block Learn how to migrate CMS Block GUI Learn how to migrate CMS Block Collector Learn how to migrate CMS Block Category Connector Learn how to migrate CMS Collector</body>
</html>