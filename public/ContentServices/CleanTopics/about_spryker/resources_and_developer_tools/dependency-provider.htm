<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Each(Undefined variable: General.bundles/modules)ships with aDependencyProviderclass which explicitly defines services and external dependencies to other(Undefined variable: General.bundles/modules). For instance when the Cms(Undefined variable: General.bundle/module)requires the Glossary(Undefined variable: General.bundle/module)this needs to be configured here. TheDependencyProviderdefines dependencies for each layer. Usually you require some of these classes: Services (Common functionality for Client, Yves and Zed) Plugins Facades Query Containers As you can see in the example these required classes are wrapped into a closure to enable lazy loading. Inside of the closure you get a$containervariable which gives you access to a so called service locator to retrieve the required classes like this:$container-&gt;getLocator()-&gt;glossary()-&gt;facade(). You can use any(Undefined variable: General.bundle/module)name instead of-&gt;glossary(). The structure is always the same so you can copy and adopt it for your use case. &lt;?php
class CmsDependencyProvider extends SprykerCmsDependencyProvider
{ const FACADE_GLOSSARY = 'FACADE_GLOSSARY'; const MY_PLUGINS = 'MY_PLUGINS'; const SERVICE_UTIL_SANITIZE = 'SERVICE_UTIL_SANITIZE'; public function provideBusinessLayerDependencies(Container $container) { // Provide access to a facade from another bundle (Glossary in this example) $container[static::FACADE_GLOSSARY] = function (Container $container) { return $container-&gt;getLocator()-&gt;glossary()-&gt;facade(); } // Provide a stack of plugins from other bundles $container[static::MY_PLUGINS] = function (Container $container) { return [ new APlugin(), new BPlugin(), ]; }; // Provide a service from another bundle (UtilSanitize in this example) $container[static::SERVICE_UTIL_SANITIZE] = function (Container $container) { return $container-&gt;getLocator()-&gt;utilSanitize()-&gt;service(); }; };
} How to use the provided class? You can access the classes which are provided by theDependencyProviderin the Factory . Technically the$containervariable is a simple DI-container based on Pimple . The contained class is initialized only when you use it. &lt;?php
class CmsBusinessFactory extends AbstractBusinessFactory
{ /** * Returns an instance of the provided glossary facade. * * @return CmsToGlossaryInterface */ protected function getGlossaryFacade() { return $this-&gt;getProvidedDependency(CmsDependencyProvider::FACADE_GLOSSARY); }
} Snippet for a new dependency provider To create a new dependency provider you can copy and adopt the snippet. Just renameconst FACADE_FOO_BARandfooBar()according to your requirements. &lt;?php
namespace Pyz\Zed\MyBundle; use Spryker\Zed\Kernel\AbstractBundleDependencyProvider;
use Spryker\Zed\Kernel\Container; class MyBundleDependencyProvider extends AbstractBundleDependencyProvider
{ const FACADE_FOO_BAR = 'FACADE_FOO_BAR'; /** * @param Container $container * * @return Container */ public function provideBusinessLayerDependencies(Container $container) { $container[static::FACADE_FOO_BAR] = function (Container $container) { return $container-&gt;getLocator()-&gt;fooBar()-&gt;facade(); }; return $container; } } New bundles will not be auto-completable in your IDE just yet. Runvendor/bin/console dev:ide:generate-auto-completionto also get IDE typehinting for those, the yellow “markup” will go away. Bridges in Spryker Core When you look into dependency provider classes from the core level, you will discover the existence of bridges. Inside of Spryker’s Core we are using the Bridge pattern to avoid hard dependencies and to further decouple the bundles form each other. This is not needed in the project code and we recommend to avoid it to reduce overhead. &lt;?php
$container[static::FACADE_GLOSSARY] = function (Container $container) { // Here we return the bridge instead of the required facade. Core only! return new CmsToGlossaryBridge($container-&gt;getLocator()-&gt;glossary()-&gt;facade());
}; The same is true for services.</body>
</html>