<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>We use Jenkins for cronjob scheduling. Compared to Crontab, there are several benefits: Jobs are queued and can be manually executed Job definitions are under version control and can be changed by any developer Console output available for debugging Add a new job and run it Jobs are defined inconfig/Zed/cronjobs/jobs.php This file contains an array which defines the jobs. // Send emails every 10 minutes
$jobs[] = [ 'name' =&gt; 'send-mails', 'command' =&gt; '$PHP_BIN vendor/bin/console mail:send-mail', 'schedule' =&gt; '*/10 * * * *', 'enable' =&gt; true, 'run_on_non_production' =&gt; true, 'stores' =&gt; ['DE', 'FR'],
]; To import this configuration to Jenkins you need to run this command in the console. In a production environment, this is part of the deployment process. vendor/bin/console setup:jenkins:generate Now you can open Jenkins on port 10007 and watch your scripts running: http://zed.de.demoshop.local:10007 (URL works for standard VM, you may use a different host name). Cronjob Configuration For each job you can define several configurations: Key Type Purpose Mandatory name string Name of the job yes command string The console command that is executed. yes schedule string Expression that defines the job schedule (how often the job is executed). The schedule string is compatible with cronjob schedule definition (eg. 0 * * * * means: run once each hour at 00 minute). If environment is development, return empty string - cronjobs are being executed on development environment only manually. yes enable bool Enable/Disable jobs yes stores array An array of stores where the job is executed. yes run_on_non_production bool Defines, if the job also runs on environments other than production (development, testing, staging). Default: false no When not using Jenkins for job scheduling there is no locking between concurrently running commands.</body>
</html>