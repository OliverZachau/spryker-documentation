<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Overview Spryker Middleware is a constructor that allows you to set up a linear data processing flow, also referred to as pipeline, for import/export of data from some system to shop, or from shop to some system. For example, it can be used for importing products to a shop, or exporting orders from a shop. Pipeline Structure The Middleware applies the pipeline pattern allowing to connect different stages of data processing together and inverting dependencies between them. The imported/exported items are processed one by one and go through a set of specific steps called “stages”. The pipeline contains 5 stages: reader, validator, mapper, translator, writer. First of all, a source item isread. Then it isvalidatedto make sure that all attributes etc. are correct and all the necessary data is available. Having passed the validation, the item ismapped, i.e. keys of the source system are mapped onto the target system. This being done, the items go through atranslatorwhich processes the values and translates them into a respective format (for example, the price value is a decimal value, but should be init - it’s translator’s responsibility to change it to the required value). After that, the item iswrittento the target system (to the database, in case of import, to a file, if it’s export etc.). Each stage can be abstracted as having: Input – item is received from the previous stage, exception might be a reader, which receives nothing. Output – item is provided for the next stage, exception might be a writer, which persists data and sends back nothing. Configuration – configuration of the stage, e.g. validation rules for the validator. Logging – used by any stage to leave some artefacts of processing data. The incoming data are taken from the stream - the Middleware does not care about the source of the data, whether they come from a file, from an API etc. The middleware provides its own interface, so the source of the data does not really matter. How the Middleware Works The Middleware provides a console interface to allow job triggering and Jenkins integration. It is evoked by running the commandmiddleware:process: run. The main parameter of the command is-p(process name) which defines the process to be started. The default implementation of the middleware constructor includes the interface, reading/writing from/to JSON, .csv, .xml formats, business logic of mapping, translation and validation (you can add your own translators and validators). There are two main plugin interfaces, which should be implemented to configure Middleware Process:ConfigurationProfilePluginInterfaceandProccessConfigurationPluginInterface. TheConfigurationProfilePluginInterfaceregisters the processes (like import/export) and the list of custom translators/validators (if any) implemented at the project level. The interface can be implemented in any module under\Spryker\Zed\[MODULE]\Communication\Plugin\Configuration. This plugin implements the interface as follows: Click here to expand the code sample class AkeneoPimConfigurationProfilePlugin extends AbstractPlugin implements ConfigurationProfilePluginInterface
{ /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Configuration\ProcessConfigurationPluginInterface[] */ public function getProcessConfigurationPlugins(): array { return $this-&gt;getFactory() -&gt;getAkeneoPimProcesses(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\TranslatorFunction\TranslatorFunctionPluginInterface[] */ public function getTranslatorFunctionPlugins(): array { return $this-&gt;getFactory() -&gt;getAkeneoPimTranslatorFunctions(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Validator\ValidatorPluginInterface[] */ public function getValidatorPlugins(): array { return []; }
} Each process is a separate plugin that consists of the following methods (ProcessConfigurationPluginInterface): getProcessName- returns the process name which is used to find necessary process with the parameter (transferred with -p option). getInputStreamPlugin- configures the source from where the data is read. getOutputStreamPlugin- configures the target where the data is written. getIteratorPlugin- either does nothing and releases the input stream for processing as is, or alters the data for further processing. For example, if the input stream is just a file, the iterator does nothing and lets the data be processed further. If the input stream is, for example, a file catalog,getInputStreamPluginreturns the file name, the iterator goes through all the files, and if, say each file is in JSON format, the iterator returns each JSON file of the catalog for processing to pipeline. You can use one of two iterators that are provided out of the box (NullIterator, JsonDirectoryIterator) or implement your own iterator. getStagePlugin- contains a list of all stages the items go through (reader, validator, mapper, translator, writer) and makes sure each item passes each stage one by one. getLoggerPlugin- defines the way logging happens. The default Middleware logger logs to the PHP standard error stream (php://stderr) (this can be changed as needed). Detalization of the logging is fully customizable, which means you can configure it as you wish. getPreProcessHookPluginsandgetPostProcessHookPlugins- define what should be done prior to or after a process. For example, it might be necessary to download a file with the categories prior to the categories import: this would be specified ingetPreProcessHookPlugins. Click here to expand the code sample class CategoryImportConfigurationPlugin extends AbstractPlugin implements ProcessConfigurationPluginInterface
{ const PROCESS_NAME = 'CATEGORY_IMPORT_PROCESS'; /** * @return string */ public function getProcessName(): string { return static::PROCESS_NAME; } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Stream\InputStreamPluginInterface */ public function getInputStreamPlugin(): InputStreamPluginInterface { return $this-&gt;getFactory() -&gt;getCategoryImportInputStreamPlugin(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Stream\OutputStreamPluginInterface */ public function getOutputStreamPlugin(): OutputStreamPluginInterface { return $this-&gt;getFactory() -&gt;getCategoryImportOutputStreamPlugin(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Iterator\ProcessIteratorPluginInterface */ public function getIteratorPlugin(): ProcessIteratorPluginInterface { return $this-&gt;getFactory() -&gt;getCategoryImportIteratorPlugin(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\StagePluginInterface[] */ public function getStagePlugins(): array { return $this-&gt;getFactory() -&gt;getCategoryImportStagePluginsStack(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Log\MiddlewareLoggerConfigPluginInterface */ public function getLoggerPlugin(): MiddlewareLoggerConfigPluginInterface { return $this-&gt;getFactory() -&gt;getAkeneoPimLoggerConfigPlugin(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Hook\PreProcessorHookPluginInterface[] */ public function getPreProcessorHookPlugins(): array { return $this-&gt;getFactory() -&gt;getCategoryImportPreProcessorPluginsStack(); } /** * @return \SprykerMiddleware\Zed\Process\Dependency\Plugin\Hook\PostProcessorHookPluginInterface[] */ public function getPostProcessorHookPlugins(): array { return $this-&gt;getFactory() -&gt;getCategoryImportPostProcessorPluginsStack(); }
} Code Organization The Middleware is a set of modules in the Middleware namespace allowing to group common functionalities together. The middleware cannot provide readers and writers for all systems, these should be implemented in scope of respective modules and namespaces. Here is an example of code organization for a project: Middleware Integration The core of the Spryker Middleware is implemented in the Process module. This module collects all process plugins and creates processes out of them. To install Process module add the Process repository to your repositories in composer.json, do the following: repositories": [ ... { "type": "git", "url": "https://github.com/spryker-middleware/process.git" }
], Then run this command in console: composer require spryker-middleware/process AddSprykerMiddlewarenamespace to your project’s core namespaces: $config[KernelConstants::CORE_NAMESPACES] = [ 'SprykerShop', 'SprykerMiddleware', 'SprykerEco', 'Spryker',
]; Add Middleware Process console command toConsoleDependencyProviderin your project: …
use SprykerMiddleware\Zed\Process\Communication\Console\ProcessConsole;
…
protected function getConsoleCommands(Container $container)
{ $commands = [ … new ProcessConsole(), ]; … return $commands;
} Add Process module on project level and specify configuration profiles inProcessDependencyProvider: class ProcessDependencyProvider extends SprykerMiddlewareProcessDependencyProvider
{ … protected function getConfigurationProfilePluginsStack(): array { $profileStack = parent::getConfigurationProfilePluginsStack(); $profileStack[] = new PimConfigurationProfilePlugin(); $profileStack[] = new DefaultConfigurationProfilePlugin(); return $profileStack; }
} See this example on how to implement a process. Middleware Reports You can view the results of the Spryker Middleware processes in MiddlewareReportssection underMaintenancemenu of the Administration interface. ThisMiddleware Reportssection provides an overview of all the processes run with Middleware, overview of the process results (start time, duration, item count and status of each process) as well as the detailed information on each process. The detailed information includes: Process details: -process name -process start/end times -process duration -items count -processed items -skipped items -status -duration Configuration details: -iterator plugin -input stream plugin -output stream plugin -logger plugin -stage plugins -pre process hook plugins -post process hook plugins -paths (if applicable) Process stage results: -stage name -input item count -output item count -total execution time -average item execution time Reports Integration To install Report module, add the Report repository to your repositories in composer.json: repositories": [ ... { "type": "git", "url": "https://github.com/spryker-middleware/report.git" }
], Then run this command in console: composer require spryker-middleware/report To add reporting functionality to your Middleware process, add the following plugin to the list of post hook plugins in your Process configuration: use SprykerMiddleware\Zed\Report\Communication\Plugin\Hook\ReportPostProcessorHookPlugin;
...
public function getPostProcessorHookPlugins(): array
{ return [ ... new ReportPostProcessorHookPlugin(), ];
}
... After that you will be able to see the result of your process runs in the Admin UI (Maintenance\ Middleware Reports). OmsMiddlewareConnector Module TheOmsMiddlewareConnectormodule providesTriggerOrderExportProcessCommandwhich enables triggering of a Middleware process from OMS. Also this module providesOrderReadStreamPluginthat provides input stream for reading orders and pass them to next stages of Middleware process. To installOmsMiddlewareConnectormodule add theOmsMiddlewareConnectorrepository to your repositories in composer.json, do the following: repositories": [ ... { "type": "git", "url": "https://github.com/spryker-middleware/oms-middleware-connector.git" }
], Then run this command in console: composer require spryker-middleware/oms-middleware-connector Please refer to config/Shared/config.dist.php for example of module configuration. To set up the order export process which should be triggered from OMS command, add configuration of its name to your project’s config: $config[OmsMiddlewareConnectorConstants::ORDER_EXPORT_PROCESS_NAME] = OrderExportProcessConfigurationPlugin::PROCESS_NAME; NowTriggerOrderExportProcessCommandis available and can be registered in OmsDependencyProvider as well as used in your Oms configuration: ...
/**
* @param \Spryker\Zed\Kernel\Container $container
*
* @return \Spryker\Zed\Kernel\Container
*/
public function provideBusinessLayerDependencies(Container $container)
{ $container = parent::provideBusinessLayerDependencies($container); $container-&gt;extend(self::COMMAND_PLUGINS, function (CommandCollectionInterface $commandCollection) { $commandCollection-&gt;add(new TriggerOrderExportProcessCommand(), ‘Order/Export); return $commandCollection; }); return $container;
}
... Last	review date: April, 25th, 2018</body>
</html>