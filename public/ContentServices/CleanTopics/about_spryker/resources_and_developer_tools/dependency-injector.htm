<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>The Dependency Provider defines which “external dependencies” you need to retrieve(e.g. a facade of another(Undefined variable: General.bundle/module)). TheDependencyInjectoris the opposite of it. This class will push dependencies into another(Undefined variable: General.bundle/module)without the need to touch the(Undefined variable: General.bundle/module)where it injects to ( OCP ). For instance, let’s consider you have a(Undefined variable: General.bundle/module)that handles the integration with a payment service(e.g. Payolution). In order to make this payment option available, you need to inject some functionality from this(Undefined variable: General.bundle/module)into the Checkout. To achieve this you need to consider the following aspects: ADependencyProviderwith defined hooks. ADependencyInjectorthat injects the functionality. Configure from which(Undefined variable: General.bundles/modules)the functionality should be injected to which(Undefined variable: General.bundle/module). Dependency Injectors This technique of injecting dependencies can be used both in Yves and Zed. Example: You can see in the example below the dependency provider from theCheckout (Undefined variable: General.bundle/module). &lt;?php
namespace Spryker\Yves\Checkout; use Spryker\Yves\Kernel\AbstractBundleDependencyProvider;
use Spryker\Yves\Kernel\Container;
use Spryker\Yves\StepEngine\Dependency\Plugin\StepHandlerPluginCollection;
use Spryker\Yves\StepEngine\Dependency\Plugin\SubFormPluginCollection; class CheckoutDependencyProvider extends AbstractBundleDependencyProvider
{ const PAYMENT_METHOD_HANDLER = 'payment method handler'; const PAYMENT_SUB_FORMS = 'payment sub forms'; /** * @param \Spryker\Yves\Kernel\Container $container * * @return \Spryker\Yves\Kernel\Container */ public function provideDependencies(Container $container) { $container[static::PAYMENT_SUB_FORMS] = function () { return new SubFormPluginCollection(); }; $container[static::PAYMENT_METHOD_HANDLER] = function () { return new StepHandlerPluginCollection(); }; return $container; } } The DependencyProvider defines some hooks in the container, which then can be used to inject additional functionality to them. In our example, we want to addPayolutionas a payment option in checkout but without making any modifications in theCheckout(Undefined variable: General.bundle/module). We want to extend the functionality from theCheckoutby adding this payment option. TheCheckout (Undefined variable: General.bundle/module)has the knowledge on how to handle the process that starts after a new order is submitted; theCheckout (Undefined variable: General.bundle/module)doesn’t need to know details regarding which payment or delivery methods are available. This functionality is injected by implementing aDependencyInjectorInterfacein the(Undefined variable: General.bundle/module)that does the integration with the payment service(Payolutionin our case). The dependencies defined in the dependency provider from theCheckout (Undefined variable: General.bundle/module)are then extended with the required functionality. Click to expand the code sample) &lt;?php
namespace Spryker\Yves\Payolution\Dependency\Injector; use Spryker\Shared\Kernel\ContainerInterface;
use Spryker\Yves\CheckoutStepEngine\CheckoutDependencyProvider;
use Spryker\Yves\CheckoutStepEngine\Dependency\Plugin\CheckoutStepHandlerPluginCollection;
use Spryker\Yves\CheckoutStepEngine\Dependency\Plugin\CheckoutSubFormPluginCollection;
use Spryker\Yves\Kernel\Dependency\Injector\AbstractDependencyInjector; class CheckoutDependencyInjector extends AbstractDependencyInjector
{ /** * @param \Spryker\Shared\Kernel\ContainerInterface|\Spryker\Yves\Kernel\Container $container * * @return \Spryker\Shared\Kernel\ContainerInterface|\Spryker\Yves\Kernel\Container */ public function inject(ContainerInterface $container) { $container-&gt;extend(CheckoutDependencyProvider::PAYMENT_SUB_FORMS, function (CheckoutSubFormPluginCollection $paymentSubForms) { $paymentSubForms-&gt;add(...); return $paymentSubForms; }); $container-&gt;extend(CheckoutDependencyProvider::PAYMENT_METHOD_HANDLER, function (CheckoutStepHandlerPluginCollection $paymentMethodHandler) { $paymentMethodHandler-&gt;add(...); return $paymentMethodHandler; }); return $container; } } Naming The class name is important for resolving. The dependency injector resolver will always look for a class named likeNamespace\Application\(InjectFromBundle)\Dependency\Injector\(InjectToBundle)DependencyInjector. &lt;?php
...
$config[KernelConstants::DEPENDENCY_INJECTOR_YVES] = [ 'Checkout' =&gt; [ // bundle to inject to 'Payolution', // bundle which injects functionality '...' ]
]; $config[KernelConstants::DEPENDENCY_INJECTOR_ZED] = [ ...
];
... More(Undefined variable: General.bundles/modules)can inject functionality into the same(Undefined variable: General.bundle/module). There is no limitation on this matter. In our example, you can have more(Undefined variable: General.bundles/modules)that integrate with payment providers and from each of them you can inject functionality into theCheckout. How to use the injected functionality? Inside the Factory you can simply use your defined dependency. When nothing is injected you will only get what you have defined in your dependency provider, in this example an empty collection. But you also can define some defaults that you want to use. The injector just adds more functionality. &lt;?php
namespace Pyz\Yves\Checkout\Form; use Spryker\Yves\Checkout\CheckoutDependencyProvider;
use Spryker\Yves\Kernel\AbstractFactory; class FormFactory extends AbstractFactory
{ /** * @return \Spryker\Yves\StepEngine\Dependency\Plugin\Form\SubFormPluginCollection */ protected function createPaymentMethodSubForms() { return $this-&gt;getProvidedDependency(CheckoutDependencyProvider::PAYMENT_SUB_FORMS); } }</body>
</html>