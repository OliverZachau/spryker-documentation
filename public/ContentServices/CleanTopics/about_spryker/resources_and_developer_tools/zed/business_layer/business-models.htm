<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>Business models are classes where you program the business logic of your system. With business logic we mean all kinds of algorithms (e.g. cart calculation), storage procedures (e.g. checkout save workflow) and interactions with external providers (e.g. payment). Business models are not visible from other layers and bundles. Although their methods are public they must not be used directly from the outside. In Java we would use the package-private access modifier, so that methods can only be called from within the same package/(Undefined variable: General.bundle/module). In PHP this modifier is missing, so instead of a explicit declaration we only have a convention. Dependency Injection Business models must not directly depend on each other. The dependency container injects dependencies to the constructor and we use interfaces to not depend on concrete classes. This is very important for testability and decoupling. It also allows to use country-specific extensions of models. A typical constructor and the related properties of a business model looks like this: &lt;?php
class KeyManager implements KeyManagerInterface
{ /** * @var GlossaryQueryContainerInterface */ protected $queryContainer; /** * @var KeySourceInterface */ protected $keySource; /** * @param KeySourceInterface $keySource * @param GlossaryQueryContainerInterface $queryContainer */ public function __construct(KeySourceInterface $keySource, GlossaryQueryContainerInterface $queryContainer) { $this-&gt;keySource = $keySource; $this-&gt;queryContainer = $queryContainer; } As you can see, the classKeyManagerdepends on two other classes which are specified by their related interfaces. The constructor gets them injected and provides them as properties for the model’s methods. Please obey that theKeyManagerimplements aKeyManagerInterfacethat is used by other models who depend on theKeyManager. Every business model ships with an interface which exposes all public methods. Avoid Hybrids In case you need data objects, you can use transfer objects, entities or you can create your own DTOs for internal use. In any case do not mix them up with the business models. Each class is either a stateless model with functional methods or a data object with getters and setters. Avoid hybrids is a rule from the Clean Code book. The following example is a violation of this rule because it mixes : &lt;?php
public function __construct(ModelInterface $myModel, array $data)
{ $this-&gt;myModel = $myModel; $this-&gt;data = $data;
}</body>
</html>