<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>This chapter will help you model a state machine using Spryker to manage your sale orders. First of all, it’s important to know which tasks must be executed after an order is submitted and in which order. Keep in mind that you can define more than one state machine in your system to cover the use case scenarios you want to enable in your shop. Before starting the development and configuration for a new state machine, it’s important to draw on a paper the sequence of the processes that must take place after an order is placed and to think about any scenario that could take place (the order is over/under paid, the order could not be delivered at the given address, etc.). Of course, the state machine can be improved/fixed if you observe that not every possible use case scenario is covered or if the order is not managed as expected. Just as an exercise to understand how to draw and implement a state machine that can help you manage orders, we’ll build together a state machine that manages prepaid orders. Please keep in mind that this tutorial is focused on the steps that should be performed in order to add a new state machine in your application, and not on the use case scenario itself. This example should not be used in a production environment since it’s not complete. This use case scenario must implement the following behaviors: the payment must be done before packing the order. after the order is paid, it can be packed and shipped to the customer. the customer can return order items within 100 days since the order was placed. if the customer returns order items, the refund process must be initiated. after 100 days have passed, the order is considered completed. after a return, the order is considered completed. Please follow the steps described below to model the prepaid state machine: Create the XML file Identify the states Identify the events Define the transitions Development Integrate the State Machine Create the XML file To start defining your new state machine, create a new XML file underconfig/Zed/oms/calledPrepayment.xml. For the moment the file will contain only the name of the process that we are currently building (Prepayment). &lt;?xml version="1.0"?&gt;
&lt;statemachine xmlns="spryker:oms-01" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="spryker:oms-01 http://static.spryker.com/oms-01.xsd"&gt; &lt;process name="Prepayment" main="true"&gt; &lt;/process&gt; &lt;/statemachine&gt; We added themain="true"attribute to the process because this process manages an entire workflow. Given that there are many parts that are similar between the state machines that a system needs, you can reuse parts of them as subprocesses. Subprocesses are described in the XML file similar as the oms processes, the only process is the value of this attribute(main="false"). To see a graphical representation of the current state of your state machine in Zed, register the state machine in the OmsConfig. &lt;?php
namespace Pyz\Zed\Oms; use Generated\Shared\Transfer\OrderTransfer;
use Spryker\Zed\Oms\OmsConfig as SprykerOmsConfig; class OmsConfig extends SprykerOmsConfig
{ const ORDER_PROCESS_PREPAYMENT = 'Prepayment'; /** * @return string */ public function getProcessDefinitionLocation() { return APPLICATION_ROOT_DIR . '/config/Zed/oms/'; } /** * @return array */ public function getActiveProcesses() { return [ //.. static::ORDER_PROCESS_PREPAYMENT, ]; }
} Identify the States Now, let’s identify the states in which the order can be at a moment. Which are the steps in which a order must pass to complete a prepaid order? New Invoice generated Invoice sent Waiting for payment Payment reminder sent Payment received Order canceled Order exported Order shipped Ready for return Refund initiated Order completed Add these states in the XML file you previously created, as in the example below: &lt;?xml version="1.0"?&gt;
&lt;statemachine xmlns="spryker:oms-01" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="spryker:oms-01 http://static.spryker.com/oms-01.xsd"&gt; &lt;process name="Prepayment" main="true"&gt; &lt;states&gt; &lt;state name="new"/&gt; &lt;state name="invoice generated"/&gt; &lt;state name="invoice sent"/&gt; &lt;state name="waiting for payment"/&gt; &lt;state name="cancelled"/&gt; &lt;state name="payment received"/&gt; &lt;state name="payment reminder sent"/&gt; &lt;state name="exported order"/&gt; &lt;state name="order shipped"/&gt; &lt;state name="ready for return"/&gt; &lt;state name="refund initiated"/&gt; &lt;state name="completed"/&gt; &lt;/states&gt; &lt;/process&gt;
&lt;/statemachine&gt; You can check the current state of your state machine in Zed: Prepayment . You’ll see the states defined before, without any links between them. To pass from one state to another, a transition must be defined between two states. To be able to tell when a transition can be fired, an event attached to that transition must take place. Identify the Events Next, let’s identify the events that can tell if a transition can be fired. # Event Event Trigger Comments Create invoice onEnter=”true” Event fired automatically Send invoice onEnter=”true” Waiting for payment onEnter=”true” Payment not received timeout=”1hour” Fired after the specified time has passed Order canceled manual=”true” Event fired after user action (either from back-office or from the shop interface) Payment received manual=”true” Export order	onEnter=”true” Ship order manual=”true” Items not returned timeout=”100days” Ready for return onEnter=”true” Items returned manual=”true” Refund payment manual=”true” Now that we identified the events, we can add them in the XML file that defines our state machine. &lt;events&gt; &lt;event name="create invoice" onEnter="true" /&gt; &lt;event name="send invoice" onEnter="true" /&gt; &lt;event name="export order" onEnter="true" /&gt; &lt;event name="ship order" manual="true" /&gt; &lt;event name="waiting for payment" onEnter="true" /&gt; &lt;event name="payment not received" timeout="1hour" /&gt; &lt;event name="payment received" manual="true" /&gt; &lt;event name="ready for return" onEnter="true" /&gt; &lt;event name="item not returned" timeout="100days" /&gt; &lt;event name="items returned" manual="true" /&gt; &lt;event name="refund payment" manual="true" /&gt; &lt;event name="cancel" manual="true" /&gt; &lt;/events&gt; Timeout Events If the state machine's current state is the source state for a transition that has a timeout event attached, it will be checked periodically by a cronjob to see if that amount of time has already passed. Define the Transitions Transitions draw the links from one state to another. They are bound to an event, which tells when the transition can be fired( when the state machine can move from the current state to another state). A transition can have a condition attach which is check when the state machine is currently in the source state by a cronjob that runs periodically. Basically, the condition is linked to a PHP class that contains logic that checks if the transition can take place. Now, let’s draw the possible transitions between the previously defined states and setup the corresponding event for each of them. Click to expand the code sample &lt;transitions&gt; &lt;transition&gt; &lt;source&gt;new&lt;/source&gt; &lt;target&gt;invoice generated&lt;/target&gt; &lt;event&gt;create invoice&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;invoice generated&lt;/source&gt; &lt;target&gt;invoice sent&lt;/target&gt; &lt;event&gt;send invoice&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;invoice sent&lt;/source&gt; &lt;target&gt;waiting for payment&lt;/target&gt; &lt;event&gt;waiting for payment&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;waiting for payment&lt;/source&gt; &lt;target&gt;cancelled&lt;/target&gt; &lt;event&gt;cancel&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;waiting for payment&lt;/source&gt; &lt;target&gt;payment reminder sent&lt;/target&gt; &lt;event&gt;payment not received&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;waiting for payment&lt;/source&gt; &lt;target&gt;payment received&lt;/target&gt; &lt;event&gt;payment received&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment reminder sent&lt;/source&gt; &lt;target&gt;cancelled&lt;/target&gt; &lt;event&gt;cancel&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment reminder sent&lt;/source&gt; &lt;target&gt;payment received&lt;/target&gt; &lt;event&gt;payment received&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment received&lt;/source&gt; &lt;target&gt;exported order&lt;/target&gt; &lt;event&gt;export order&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;exported order&lt;/source&gt; &lt;target&gt;order shipped&lt;/target&gt; &lt;event&gt;ship order&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;order shipped&lt;/source&gt; &lt;target&gt;ready for return&lt;/target&gt; &lt;event&gt;ready for return&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;ready for return&lt;/source&gt; &lt;target&gt;completed&lt;/target&gt; &lt;event&gt;item not returned&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;ready for return&lt;/source&gt; &lt;target&gt;refund initiated&lt;/target&gt; &lt;event&gt;items returned&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;refund initiated &lt;/source&gt; &lt;target&gt;completed&lt;/target&gt; &lt;event&gt;refund payment&lt;/event&gt; &lt;/transition&gt; &lt;/transitions&gt; You can check the current state of your state machine in Zed: Prepayment . We can highlight the best case scenario by adding the happy=”true” attribute to the transitions, where is the case, as in the example below: &lt;transition happy="true"&gt; &lt;source&gt;ready for return&lt;/source&gt; &lt;target&gt;completed&lt;/target&gt; &lt;event&gt;item not returned&lt;/event&gt; &lt;/transition&gt; This transition would be the happy case, rather than the situation when the user returns some order items. If you check again the visual representation of the state machine we are building, you’ll observe that the best case scenario transitions are now highlighted. Adding thehappyattribute does not interfere to the behavior of the state machine; it just helps you visualize better the business processes that are modeled in the state machine. Implement the Commands and Conditions Now we can visualize the transitions defined in our state machine and we have an idea about the business processes that are involved when a prepaid order is submitted, but our state machine doesn’t do much for the moment. We need to attach the logic that gets executed when an event is fired or condition to check if a transition is possible. We’ll update the XML file that defines our state machine by adding the necessary commands and conditions to it. Click to expand the code sample &lt;?xml version="1.0"?&gt;
&lt;statemachine xmlns="spryker:oms-01" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="spryker:oms-01 http://static.spryker.com/oms-01.xsd"&gt; &lt;process name="Prepayment" main="true"&gt; &lt;states&gt; &lt;state name="new" reserved="true"/&gt; &lt;state name="invoice generated"/&gt; &lt;state name="invoice sent" /&gt; &lt;state name="waiting for payment" /&gt; &lt;state name="cancelled" /&gt; &lt;state name="payment received" /&gt; &lt;state name="payment reminder sent" /&gt; &lt;state name="exported order" /&gt; &lt;state name="order shipped" /&gt; &lt;state name="ready for return" /&gt; &lt;state name="refund initiated" /&gt; &lt;state name="completed" /&gt; &lt;/states&gt; &lt;transitions&gt; &lt;transition happy="true" &gt; &lt;source&gt;new&lt;/source&gt; &lt;target&gt;invoice generated&lt;/target&gt; &lt;event&gt;create invoice&lt;/event&gt; &lt;/transition&gt; &lt;transition happy="true"&gt; &lt;source&gt;invoice generated&lt;/source&gt; &lt;target&gt;invoice sent&lt;/target&gt; &lt;event&gt;send invoice&lt;/event&gt; &lt;/transition&gt; &lt;transition happy="true"&gt; &lt;source&gt;invoice sent&lt;/source&gt; &lt;target&gt;waiting for payment&lt;/target&gt; &lt;event&gt;waiting for payment&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;waiting for payment&lt;/source&gt; &lt;target&gt;cancelled&lt;/target&gt; &lt;event&gt;cancel&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;waiting for payment&lt;/source&gt; &lt;target&gt;payment reminder sent&lt;/target&gt; &lt;event&gt;payment not received&lt;/event&gt; &lt;/transition&gt; &lt;transition happy="true"&gt; &lt;source&gt;waiting for payment&lt;/source&gt; &lt;target&gt;payment received&lt;/target&gt; &lt;event&gt;payment received&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment reminder sent&lt;/source&gt; &lt;target&gt;cancelled&lt;/target&gt; &lt;event&gt;cancel&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment reminder sent&lt;/source&gt; &lt;target&gt;payment received&lt;/target&gt; &lt;event&gt;payment received&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment received&lt;/source&gt; &lt;target&gt;exported order&lt;/target&gt; &lt;event&gt;export order&lt;/event&gt; &lt;/transition&gt; &lt;transition happy="true"&gt; &lt;source&gt;exported order&lt;/source&gt; &lt;target&gt;order shipped&lt;/target&gt; &lt;event&gt;ship order&lt;/event&gt; &lt;/transition&gt; &lt;transition happy="true"&gt; &lt;source&gt;order shipped&lt;/source&gt; &lt;target&gt;ready for return&lt;/target&gt; &lt;event&gt;ready for return&lt;/event&gt; &lt;/transition&gt; &lt;transition happy="true"&gt; &lt;source&gt;ready for return&lt;/source&gt; &lt;target&gt;completed&lt;/target&gt; &lt;event&gt;item not returned&lt;/event&gt; &lt;/transition&gt; &lt;transition&gt; &lt;source&gt;ready for return&lt;/source&gt; &lt;target&gt;refund initiated&lt;/target&gt; &lt;event&gt;items returned&lt;/event&gt; &lt;/transition&gt; &lt;transition condition="Prepayment/IsRefundApproved"&gt; &lt;source&gt;refund initiated&lt;/source&gt; &lt;target&gt;completed&lt;/target&gt; &lt;event&gt;refund payment&lt;/event&gt; &lt;/transition&gt; &lt;/transitions&gt; &lt;events&gt; &lt;event name="create invoice" onEnter="true" command="Prepayment/CreateInvoice" /&gt; &lt;event name="send invoice" onEnter="true" command="Prepayment/SendInvoice" /&gt; &lt;event name="export order" onEnter="true" /&gt; &lt;event name="ship order" manual="true" /&gt; &lt;event name="waiting for payment" onEnter="true" /&gt; &lt;event name="payment not received" timeout="1hour" command="Prepayment/UpdatePaymentStatus" /&gt; &lt;event name="payment received" manual="true" command="Prepayment/UpdatePaymentStatus" /&gt; &lt;event name="ready for return" onEnter="true" /&gt; &lt;event name="item not returned" timeout="100days" /&gt; &lt;event name="items returned" manual="true" command="Prepayment/UpdateOrder" /&gt; &lt;event name="refund payment" manual="true" command="Prepayment/RefundPayment" /&gt; &lt;event name="cancel" manual="true" command="Prepayment/CancelOrder" /&gt; &lt;/events&gt; &lt;/process&gt;
&lt;/statemachine&gt; Now check again the Prepayment state machine in Zed. You’ll see that some of the events now have commands associated and some of the transitions appear to have conditions attached, but they are marked as being not yet implemented. For our state machine to be functional, we need to implement the configured commands and conditions. The implementation for the commands will be placed intheOMS(Undefined variable: General.bundle/module)on the project level, underCommunication/Plugin/Oms/Commandand for the conditions underCommunication/Plugin/Oms/Condition. After you finish with the implementation, the code must be linked to the XML file where we defined the state machine. To pass the right implementations of commands/conditions to your state machine, you must register the plugins in theOmsDependencyProvider: the conditions will be registered under thegetConditionPlugins()and the commands under thegetCommandPlugins()operation. Example: &lt;?php
namespace Pyz\Zed\Oms; use Spryker\Zed\Oms\OmsDependencyProvider as SprykerOmsDependencyProvider;
... class OmsDependencyProvider extends SprykerOmsDependencyProvider
{ /** * * @param \Spryker\Zed\Kernel\Container $container * * @return \Spryker\Zed\Oms\Communication\Plugin\Oms\Condition\ConditionInterface[] */ protected function getConditionPlugins(Container $container) { return [ 'Prepayment/IsRefundApproved' =&gt; new IsRefundApprovedPlugin(), ]; } /** * @param \Spryker\Zed\Kernel\Container $container * * @return \Spryker\Zed\Oms\Communication\Plugin\Oms\Command\CommandInterface[] */ protected function getCommandPlugins(Container $container) { return [ 'Prepayment/CreateInvoice' =&gt; new CreateInvoicePlugin(), 'Prepayment/SendInvoice' =&gt; new SendInvoicePlugin(), 'Prepayment/UpdatePaymentStatus' =&gt; new UpdatePaymentStatusPlugin(), 'Prepayment/UpdateOrder' =&gt; new UpdateOrderPlugin(), 'Prepayment/RefundPayment' =&gt; new RefundPaymentPlugin(), 'Prepayment/CancelOrder' =&gt; new CancelOrderPlugin(), ]; }
} Now check again the Prepayment state machine in Zed. You’ll see that the implementation is linked to the state machine. Integrate the State Machine You can have more than one state machines defined in your application and apply them according to the details of the order that gets submitted. E.g.: you can have a state machine that doesn’t involves shipping for goods that are delivered electronic. Also, you can have a dedicated state machine for each payment method (invoice payment method involves other patterns than credit card payment does). The mapping between a submitted order and the corresponding state machine that is able to process the payment is done in theSalesConfigclass, under thedetermineProcessForOrderItem(OrderTransfer $order, QuoteTransfer $request)operation; here, you will set the corresponding process for your order. &lt;?php $order-&gt;setProcess('Prepayment');</body>
</html>