<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>State machines are a model of computation used to automate processes. In Spryker you can use theOMS(Undefined variable: General.bundle/module)to automate the management of orders or theStateMachine (Undefined variable: General.bundle/module)to automate other processes you define in your shop. Both behave similar, but theOMSone is a customized solution to manage the orders in a shop. The machine can be in one of a finite number of states and it can be only in one state at a time. ( e.g. : state machine is inwaiting for paymentstate ). State machines can model problems that involve performing of a predetermined sequence of actions that depend on a sequence of events (e.g. : order is being shipped if the payment is successful). State-Machine Components E-Commerce companies need to implement highly individual processes that need to be continuously improved. Instead of building code for every process or adapting standard functionality of a shop system, Spryker takes a totally different approach. The order process is modelled with states and transitions and it’s then transferred to an XML notation. The XML format is understood and executed by Sprykers Zed engine. Zed executes the process model, no need to program a specification anymore. You can define a state machine for each process you identify in your application. For example, the process of managing orders that use credit card as a payment type is different than the orders that use invoice. You can define for each a separate state machine and when a new order is submitted you can choose which of the available state machines you want to manage it. States What are the relevant elements of a state machine? States allow to describe in which state a sales order respectively the sales order item is in. States can reflect everything that needs to be considered in your order processing. If you you have a build to order process, one state could be “waiting for production finished”. If you sell digital goods one state could be download for customer activated. In case of physical goods a state calledshippedreflects that the sales order or some items have been shipped. How are the states modeled in XML? A list of state elements can be defined with this simple XML. First the state has a name, that allows to reference the state. The display attribute allows to define a glossary key that contains the translation for the state name. &lt;states&gt; &lt;state name="new" reserved="true"/&gt; &lt;state name="paid" display="customer.order.state.received"&gt; &lt;flag&gt;invoicable&lt;/flag&gt; &lt;/state&gt; &lt;state name="shipped" display="custom.order.state.shipped" /&gt;
&lt;/states&gt; Furthermore a state can contain several flags. Flagged Items Sometimes you need to have the ability to check if items are in a certain state. For determining if an order is flagged, OmsFacade exposes two operations: isOrderFlagged($idOrder, $flag) - check if order contains at least a flag ( at least one order item is flagged ) isOrderFlaggedAll($idOrder, $flag) - check if the entire order is flagged ( all order items are flagged) Example: &lt;states&gt;
.. &lt;state name="paid"&gt; &lt;flag&gt;ready for invoice&lt;/flag&gt; &lt;/state&gt;
&lt;/states&gt; Transitions States can be connected one to another through transitions, similar to a finite graph. Such a transition is bound to an event, which tells when the order/order item can leave the current state. For example the stateswaiting for credit card captureandcapturedare connected with a transition which expects an external eventcapture successful. States and transition define the possible flow a sales order can take and also which flow is actually not possible. Technically, transitions are very simple. A source and a target state are defined. The event tells when the transition can be fired. The event element can be omitted. This way an external call like saveOrder or triggerEvent are finished. That means that the control flow of the code goes back to the invoking method. Zed will continue the execution of the process model with the help of a cronjob. If the event element is omitted and a condition is used, Zed will use the condition to evaluate if the transition can be fired. &lt;transition condition="PackageName/ClassName" happy="true"&gt; &lt;source&gt;paid&lt;/source&gt; &lt;target&gt;shipped&lt;/target&gt; &lt;event&gt;ship it&lt;/event&gt;
&lt;/transition&gt; Transitions Attributes You can attach the following attributes to a transition: Attribute Description Example happy The attribute happy marks the transition as the happy case. When Zed renders the process model, this transition will be marked with a green shade. happy="true" condition The condition attribute allows to add PHP coding that double checks if this transition can be fired or not. The condition is evaluated when the defined event has been fired. condition="PackageName/ClassName" Conditions A transition can be conditioned : the state machine can move from one state to another if a certain condition associated to that transition is being satisfied. This can be modelled in the XML file that describes the process, as in the example below: &lt;transition condition="Oms/PaymentIsCompleted"&gt; &lt;source&gt;paid&lt;/source&gt; &lt;target&gt;shipped&lt;/target&gt; &lt;event&gt;ship it&lt;/event&gt;
&lt;/transition&gt; The mapping between the string that identifies the condition in the XML file and the actual implementation of the condition is done in theOmsDependencyProvider, in thegetConditionPluginsmethod: &lt;?php
protected function getConditionPlugins(Container $container)
{ return [ 'Oms/PaymentIsCompleted' =&gt; $container-&gt;getLocator()-&gt;oms()-&gt;pluginOmsConditionPaymentIsCompleted(), //..
];
} Another use case of using conditions is when you need to go to different target states depending on the result returned after evaluating the condition. Basically, it’s a way of implementing anif-elseblock in a state machine. Example: In the example above, we have 2 transitions defined with same source state(Payment Pending), same event(Pay) but different target states(CancelledandPaid). This means that when the Pay event is triggered and the state machine is in thePayment Pendingstate, we have 2 options for the next state. The condition is evaluated and if it returns true, the transition that has the condition attached gets executed(in this case, the state machine will move to thePaidstate). If it’s evaluated to false, the other transition gets executed(the state machine moves to theCancelledstate). You can see the corresponding XML for this use case: &lt;transition condition="Oms/PaymentIsCompleted" happy="true"&gt; &lt;source&gt;payment pending&lt;/source&gt; &lt;target&gt;paid&lt;/target&gt; &lt;event&gt;pay&lt;/event&gt;
&lt;/transition&gt; &lt;transition&gt; &lt;source&gt;payment pending&lt;/source&gt; &lt;target&gt;cancelled&lt;/target&gt; &lt;event&gt;pay&lt;/event&gt;
&lt;/transition&gt; Implementing a Condition Conditions are classes that implement the ConditionInterface which expects a method check. This will return either true or false which tells Zed whether or not a transition can be executed. &lt;?php
class PaymentIsCompleted extends AbstractPlugin implements ConditionInterface
{ /** * @param SpySalesOrderItem $orderItem * * @return bool */ public function check(SpySalesOrderItem $orderItem) { //.. }
} Checking Conditions through a Cronjob You can define a transition with a condition attached but with no event linked to it. So how is it possible to get this transition executed? The Oms(Undefined variable: General.bundle/module)contains a console command for checking conditions (oms:check-condition) that are attached to this type of transitions. This console command is configured to be periodically triggered through a cronjob. It looks for transitions with condition and without event. These special transitions are rendered with a dotted line in Zed. The use case is when you want to wait for something. E.g. “Wait in this state until the product was delivered”. &lt;transition condition="Oms/IsDelivered"&gt; &lt;source&gt;shipped&lt;/source&gt; &lt;target&gt;delivered&lt;/target&gt;
&lt;/transition&gt; Transition representation: For performance reasons it is not recommended to create scenarios where a lot of items wait. This check is executed every minute and can be time consuming. Events An event can be triggered from the outside and it starts a transition. By triggering an event we tell the state machine which transition we want to get executed and to which state to move from the current source state. Triggering an event follows the transition that has the current state as a source state and the triggered event type attached to it. The event triggers the transaction and the related command is executed. The condition(s) is/are checked afterwards. If no condition is evaluated to true, the item stays on the source state (and the timeout is reseted because it moved away for a moment). Event names should be verbs likeship,pay,authorize, while state names should express that something happened or will happen (likepaidorpayment pending,closed,cancelled). This is how an event is defined: &lt;event name="ship it" timeout="" manual="true|false" onEnter="true|false" command="PackageName/ClassName"/&gt; Event Types OnEnter Events A special type of event is theOnEnterevent. If this event is attached to a transition, the state machine automatically executes it when the current state is the same as the source state of the transition. By using theOnEnterevents you can model chain of commands that you want to get executed, because the state machine always looks if there is another thing to do after any transition that gets executed. Example: after the payment is succesfully submitted, we want to automatically start the export process. To achieve this, we can define a transition between thePaidandExportedstates with anOnEnterevent attached to it. This means that after the payment is registered, the order is ready to be prepared for shipping. Manually executable events In order to be able to trigger an event manually you need to mark it as manually executable. This means that when an order is in the same state as the source state of a transition that has a manually executable event attached to it, in the order details page from the back-office application(Zed) we should be able to see a button that corresponds to that event. By clicking the button, we are triggering the event associated to it. In the defaultZed Order Detailspage it is possible to trigger an event for a single item, a group of items or all items of the order. Timeout events Events can be triggered after a defined period of time has passed, through a timeout. Let’s assume we are trying to define the prepayment process, in which if after 15 days no payment is received, thereminder sentis fired due to the timeout. How is the reminder then technically sent? This can be implemented through a command attached to thesend first reminderevent. The command attribute references a PHP class that implements a specific interface. Every time the event is fired (automatically, after timeout), Zed makes sure the associated command is executed. If an exception occurs in the command coding, the order/orderitem stays in the source state. &lt;transition command="Oms/sendFirstReminder"&gt; &lt;source&gt;payment pending&lt;/source&gt; &lt;target&gt;first reminder sent&lt;/target&gt; &lt;event&gt;sendFirstReminder&lt;/event&gt;
&lt;/transition&gt;
&lt;/transitions&gt;
...
&lt;events&gt; &lt;event name="sendFirstReminder" manual="true" timeout="15 days"/&gt;
...
&lt;/events&gt; Invoking an Event Events can be triggered : via timeout
automatically via onEnter via facade calls viaoms:check-conditions Events Triggered via Timeout An event associated to a transition can have a timeout interval set. When that timeout interval passes, the order is transitioned to the target state. .. &lt;transition&gt; &lt;source&gt;completed but returnable&lt;/source&gt; &lt;target&gt;completed success&lt;/target&gt; &lt;event&gt;not returned&lt;/event&gt; &lt;/transition&gt;
&lt;/transitions&gt; &lt;events&gt; &lt;event name="not returned" timeout="30days"/&gt;
&lt;/events&gt;
.. The textual timeout is evaluated with \DateInterval::createFromDateString(). You can find out more about it here . Events Triggered Automatically via onEnter If an event has set the onEnter attribute on True, it will be automatically triggered when the order is in the source state of the transition that contains the event. ..
&lt;transition&gt; &lt;source&gt;paid&lt;/source&gt; &lt;target&gt;invoice created&lt;/target&gt; &lt;event&gt;create invoice&lt;/event&gt;
&lt;/transition&gt; &lt;/transitions&gt;
&lt;events&gt;
.. &lt;event name="create invoice" command="Oms/CreateInvoice" onEnter="true"/&gt;
&lt;/events&gt; In the example above, after an order is paid, the invoice is automatically created (when the state machine reaches the statepaid, it will fire thecreate invoiceevent that will run theOms/CreateInvoicecommand and it transition to theinvoice createdstate). Events Triggered via Facade Calls The Order Management System facade contains several methods that allow to trigger an event: triggerEvent triggerEventForNewItem triggerEventForNewOrderItems triggerEventForOneOrderItem triggerEventForOrderItems This is typically used if an external event is raised. Examples of external events: an asynchronous payment response; a fulfilment message from the ERP. Therefore you would implement a service that receives such a message. Next step is to correlate the event with a sales order or with the sales order items. That means you need to find the Sales Order for which the event has been raised. Correlation criteria can be the Sales Order ID or a payment transaction code that has previously saved in Zed. Afterwards the methods triggerEventForOrderItems or triggerEventForNewOrderItems can be used to trigger an event. The process needs to be in a state, where it is actually waiting for the event you are triggering. Otherwise the event would not be processed. Locking the triggered events Every time the event is triggered, a dedicated lock based on the order item IDs will be acquired. This is necessary to make sure that the same event won’t be triggered several times by incoming parallel requests. Every time an attempt to trigger an event takes place, locking process works as follows: Try to acquire a lock for target order item(s). If the lock doesn’t exist already - proceed with the process, otherwise - fail (event was already triggered by another request). When the process is finished (successfully or not) the lock will be released. Additionally, there is a cronjob that cleans outdated locks for which process did not finish successfully. You can configure the desired lock timeout interval in a(Undefined variable: General.bundle/module)configuration fileZed\Oms\OmsConfig::getStateMachineLockerTimeoutInterval()and the frequency of the cleanup job in the cronjob configuration. Commands A transition from one state to another has an event associated to it. The event can have a command associated to it, which is a piece of logic that gets executed when the event is fired. The attached command is specified in the XML file that describes the state machine, where the event is being defined: &lt;events&gt; &lt;event name="send payment request" onEnter="true" manual="true" command="Oms/SendPaymentRequest"/&gt; ...
&lt;/events&gt; The mapping between the string that identifies the command in the XML file and the actual implementation of the command is done in theOmsDependencyProvider, in thegetCommandPluginsmethod: &lt;?php
protected function getCommandPlugins(Container $container)
{ return [ 'Oms/SendPaymentRequest' =&gt; $container-&gt;getLocator()-&gt;oms()-&gt;pluginOmsCommandSendPaymentRequest(), //.. ];
} In the example above,Oms/SendPaymentRequestis mapped toPlugin/Oms/Command/SendPaymentRequest. Implementing a Command There are two types of commands: commands by order item - they get executed for each order item; implementsCommandByItemInterface commands by order - executed for all items of the order which are in the same transition; implementsCommandByOrderInterface Depending on whether you want to execute the command for all sales order items that undergo the transition or separately for each sales order item, you choose the interface you want to implement. The fully qualified class name (including namespace) is added to the corresponding event. The method run() gets executed when the event linked to the command is fired. &lt;?php
class SendPaymentRequest extends AbstractCommand implements CommandByOrderInterface
{ /** * @param array $orderItems * @param SpySalesOrder $orderEntity * @param ReadOnlyArrayObject $data * * @return array */ public function run(array $orderItems, SpySalesOrder $orderEntity, ReadOnlyArrayObject $data) { //... }
} Processes A process represents a model for things that are happening in a shop. In essence, it is a graph on which the nodes are possible statuses of the order and the vertices that connect the nodes are the transitions. Example: when submitting a new order, if the payment is done then the shipment subprocess can be initiated; if the payment was not performed, then the state machine moves to thecancelledstatus. Basically, a state machine can be described as a directed connected graph. It has a single starting state and a final state. The graphs that models the state machines are being defined in XML files that are placed underconfig/Zed/omsfolder. The XML file contains the definition of the OMS process, but in order to have a valid and functional state machine to what’s configured in the xml files, the following items must be implemented: implement the defined commands implement the defined conditions trigger events via API calls Starting a Process Zed will automatically start the corresponding order management process for an order when the sales order is being saved in the database. Zed will execute the process model until it reaches a final state ( “no Event” transition or a timeout Event). That means the control flow is only returned to the invoking method when one of these situations is reached. This is important to consider when modeling the process, because when completing the check out the user wants a synchronous answer. You can check the code that does this here
. OrdervsOrderItem Zed executes the process for every sales order item. This is helpful if you want to track that a specific item has been shipped and others are still waiting. The same for a return. A customer might keep two items and send back the third one. Therefore it is important to walk through the process on sales order item level. It is important to keep in mind when such a split might happen. Most of the times an event is fired for all sales order items at the same time. However sometimes it is important to wait in a specific state until all sales order items have a certain state or flag. Subprocesses A process can be split into multiple subprocesses, that is each related to a single independent concept (e.g.: payment subprocess, cancellation subprocess). There are several reasons for introducing subprocesses when modeling a state machine process: The flow of the process is easier to follow. If more then one process needs to be defined (e.g.: orders that are being paid before delivery and orders that are paid on delivery) then the common parts of the processes can be extracted into subprocesses and be reused. To introduce in subprocess in the main process, specify its name under the subprocesses tag, as in the example below: process name="Prepayment" main="true"&gt; &lt;subprocesses&gt; &lt;process&gt;completion&lt;/process&gt; &lt;process&gt;cancellation&lt;/process&gt; .. &lt;/subprocesses&gt;
.. and specify the path to the file in which the transitions of that subprocess are described: &lt;process name="Prepayment01" main="true"&gt; ..
&lt;/process&gt;
&lt;process name="completion" file="subprocesses/Completion.xml"/&gt;
&lt;process name="cancellation" file="subprocesses/Cancellation.xml"/&gt; In the main process add the corresponding transitions between the starting and ending states of the included subprocesses and other states (that are defined in other subprocesses or in the main process). Putting it all together The following snippet shows how all elements are brought together in an XML file. Notice that we can also define subprocesses. This allows to reuse a subprocess from several processes. Therefore thesubprocessused is declared in the &lt;subprocesses&gt; section. You need to define for each subprocess a process element that contains the name and file location as attributes. &lt;statemachine xmlns="spryker:oms-01" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="spryker:oms-01 http://static.spryker.com/oms-01.xsd"&gt; &lt;process name="CreditCardDropShipping"&gt; &lt;subprocesses&gt; &lt;process&gt;invoice creation&lt;/process&gt; &lt;/subprocesses&gt; &lt;!-- state go here --&gt; &lt;states&gt; &lt;state&gt; ... &lt;/state&gt; &lt;/states&gt; &lt;!-- Transitions go here --&gt; &lt;transitions&gt; &lt;transition&gt; ... &lt;/transition&gt; &lt;transitions&gt; &lt;!-- Events go here --&gt; &lt;events&gt; &lt;event&gt; ... &lt;/event&gt; &lt;events&gt; &lt;/process&gt; &lt;process name="invoice creation" file="subprocesses/InvoiceCreation.xml"/&gt;
&lt;/statemachine&gt; Linking Processes with Code Events can have commands attached to it, which is logic that gets executed when that event is fired. E.g.: &lt;events&gt; &lt;event name="send payment request" onEnter="true" manual="true" command="Oms/SendPaymentRequest"/&gt;
..
&lt;/events&gt; The mapping between this string and the actual implementation of the command is done through the OMS dependency provider. Similar to this, the mapping between a string linked to a condition and the implementation of the condition is also done through the OMS dependency provider. A transition from one state to another can be conditioned. It’s only possible to make that transition then if a condition is satisfied: &lt;transition condition="Oms/PaymentIsCompleted" happy="true"&gt; &lt;source&gt;paid&lt;/source&gt; &lt;target&gt;shipped&lt;/target&gt; &lt;event&gt;ship it&lt;/event&gt;
&lt;/transition&gt; Configure OMS Cronjobs Spryker has three dedicated console commands for managing orders: check timeout (oms:check-timeout) check condition (oms:check-condition) clear locks (oms:clear-locks) Thecheck timeoutconsole command checks if timeout was reached for orders that are in a state that’s source for a transition that has an event with a timeout attached. If the timeout was reached, the order moves to the next state. Thecheck conditionconsole command evaluates if the condition is satisfied for orders that are in a state that’s source for a transition that has a condition attached. If the condition is satisfied, the order moves to the next state. Theclear locksconsole command cleans up outdated event trigger locks from the database For the three console commands, a cronjob must be scheduled so that they are automatically executed on the configured time interval. Cronjob Configuration Cronjobs are configured in the jobs.php configuration file that's placed under `config/Zed/cronjobs` An example of configuring the jobs for these commands can be seen below: /* STATE MACHINE */
$jobs[] = [ 'name' =&gt; 'check-statemachine-conditions', 'command' =&gt; '$PHP_BIN vendor/bin/console oms:check-condition', 'schedule' =&gt; '*/10 * * * *', 'enable' =&gt; true, 'run_on_non_production' =&gt; true, 'stores' =&gt; $allStores,
]; $jobs[] = [ 'name' =&gt; 'check-statemachine-timeouts', 'command' =&gt; '$PHP_BIN vendor/bin/console oms:check-timeout', 'schedule' =&gt; '*/10 * * * *', 'enable' =&gt; true, 'run_on_non_production' =&gt; true, 'stores' =&gt; $allStores,
]; $jobs[] = [ 'name' =&gt; 'oms-clear-locks', 'command' =&gt; '$PHP_BIN vendor/bin/console oms:clear-locks', 'schedule' =&gt; '0 6 * * *', 'enable' =&gt; true, 'run_on_non_production' =&gt; true, 'stores' =&gt; $allStores,
]; In the example above,check timeoutandcheck conditionjobs are configured to run the console commands every 10 minutes (*/10 * * * *), clear locks is configured to run every day at 6 o’clock. More information on how to define a cron expression can be found here . Versioning the State Machines The ideal case would be that after designing your state machines and you start using them in production environment, they stay the same and they don’t need any further adjustments. However, we all know that a software product is subject of change in time. The state machines that model the order processing touch many critical parts of the system so it’s very likely to need updates in the future. When a state machine is changed but there are already orders which use this process, this part becomes important. We suggest you use versioning for your state machines. Example: First version of a state machine that is responsible with managing orders that use Paypal as a payment provider would be calledPaypal01and the XML that defines this state machine would be placed in thePaypal01.xmlfile. If an update is needed, the updated state machine would be calledPaypal02and would handle new orders that use Paypal for payment. The checkout must be changed, so that all new orders use the new process while the existing ones use the old one. As you can notice from the example, all changes that are BC breaking will result in a higher number. But it is possible to change state machines without BC breaks as well, e.g. when you just add states and transitions. BC break would be when you rename states or change the logic.</body>
</html>