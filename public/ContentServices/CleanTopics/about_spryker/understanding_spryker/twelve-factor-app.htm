<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head />
    <body>TheTwelve Factor Applicationis a methodology defined by Heroku co-founder Adam Wiggins, that contains a set of twelve principles for building modern web-based software applications. We’ll go through the 12 factors to exemplify how a project built usingSpryker Commerce OScan follow this set of principles. I. Codebase One codebase tracked in revision control, many deploys. The code of a 12 factor application always lives in a version control system. As you probably already know,Spryker Commerce OSuses Git as a version control system. II. Dependencies Explicitly declare and isolate dependencies. All the environments your code runs in need to have some dependencies. This could either be the database server or the client-side data store (Redis) or third party libraries you might need. The database server or the search engine are provisioned in the virtual machine that we offer for you to use. Basically, our virtual machine sets you up for development right away. The dependencies between(Undefined variable: General.bundle/module)s are specified explicitly in the composer.json file that can be found in the root of each(Undefined variable: General.bundle/module). III. Config Store configuration in the environment. This principle refers to the fact that you shouldn’t keep configuration hard coded in your application, but rather store it using environment variables. This enforces that the code doesn’t vary depending on the environment it runs on. The only thing that varies is the configuration and by following this principle, the configuration shouldn’t be kept on the code level. Configuration includes sensitive information such as passwords and accounts for third party payment provider for example. Given that the code is stored in source control that would give access to this sensitive data to anyone that can access the source control where the code lives. The code that communicates with third party services or with the database it’s always the same; what it varies is where the database server lives or the account on which the payment transactions are registered. IV. Backing services Treat backing services as attached resources. When we say backing services we refer to services to which the application talks to, such as a search engine, a database server or an email service. These services can be located either on the same machine where the application is running or in a different one. The code should not make a difference depending on where the service is located; they should be identified by a simple endpoint and the account details for where is the case. You can find in the documentation references to different hosting solutions. You can either use our virtual machine or deploy your application in cloud, our OS allows you this flexibility. V. Build, release, run Strictly separate build and run stages. In order to follow the twelve-factor application methodology, you need to have a strict separation between the build, release and run stages. By usingSpryker Commerce OS, you have separated configuration files for each environment: development, stage and production. VI. Processes Execute the application as one or more stateless processes. In order to improve performance when running your application in production, it’s very likely to have your application running on many servers. To follow this principle, you must make sure that each of those instances of running code are stateless. The state is kept only on the database level or in the client-side storages you use, and not by the running application instance. instance. VII. Port binding Export services via port binding. A special case on this principle would be when you have an API that’s used both by your application but also by other customers(from untrusted environment). When it’s used by your application you don’t need to go through the same security as when used by untrusted consumers of your API. For this case it’s recommended to have separated URLs for you API. VIII. Concurrency Scale out via the process model. Spryker Commerce OSis built on PHP, so you don’t have to worry about running into concurrency issues since requests run in parallel. IX. Disposability Maximize robustness with fast startup and graceful shutdown. The key to be able to release often is to have a fast startup. Once new code is deployed, your application should be ready to handle requests. Tasks that need to happen after deploying the code slow down this process. This applies also for shutting down the application: your application should be robust against crashing. It’s not recommended to have to run cleanup tasks when the application shutdowns. X. Dev/prod parity Keep development, staging, and production as similar as possible. When building an application usingSpryker Commerce OS, the only thing that varies between development, staging and production environment is the configuration. You have a separated configuration file for each environment. For example, regarding the integration with third party payment provider, you’ll want to use a test account and its corresponding test gateway on development environment so that the requests are submitted in test mode. On the other hand, for production environment you’ll need to use the production account. This can be easily achieved by having separated configuration. XI. Logs Treat logs as event streams. Spryker Commerce OSenables integration with New Relic for performance monitoring. New Relic contains a set of powerful features that helps you monitor the performance and health of your application. Every request is automatically logged by New Relic. XII. Admin processes Run admin/management tasks as one-off processes. Once you run in production, you’ll need to do many one-off administrative tasks, such as database migrations or data cleanup on bad data you discover. These tasks should be performed from a machine in the production environment that’s running the latest version of production code. In other words, the one-off admin tasks should be executed from an identical environment as production. It’s not recommended to run these updates directly against a database or from a local command line window.</body>
</html>