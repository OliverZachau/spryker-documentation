define({"596":{i:0.00129781797988067,u:"../content/resources/gluepublicspec/swagger-ui/oauth2-redirect.html",a:"\r\n    \u0027use strict\u0027;\r\n    function run () {\r\n        var oauth2 = window.opener.swaggerUIRedirectOauth2;\r\n        var sentState = oauth2.state;\r\n        var redirectUrl = oauth2.redirectUrl;\r\n        var isValid, qp, arr;\r\n        if (/code|token|error/.test(window.location.hash)) {\r\n            qp = window.location.hash.substring(1);\r\n        } else {\r\n            qp = location.search.substring(1);\r\n        }\r\n        arr = qp.split(\"\u0026\")\r\n        arr.forEach(function (v,i,_arr) { _arr[i] = \u0027\"\u0027 + v.replace(\u0027=\u0027, \u0027\":\"\u0027) + \u0027\"\u0027;})\r\n        qp = qp ? JSON.parse(\u0027{\u0027 + arr.join() + \u0027}\u0027,\r\n                function (key, value) {\r\n                    return key === \"\" ? value : decodeURIComponent(value)\r\n                }\r\n        ) : {}\r\n        isValid = qp.state === sentState\r\n        if ((\r\n          oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\r\n          oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\r\n        ) \u0026\u0026 !oauth2.auth.code) {\r\n            if (!isValid) {\r\n                oauth2.errCb({\r\n                    authId: oauth2.auth.name,\r\n                    source: \"auth\",\r\n                    level: \"warning\",\r\n                    message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn\u0027t returned from auth server\"\r\n                });\r\n            }\r\n            if (qp.code) {\r\n                delete oauth2.state;\r\n                oauth2.auth.code = qp.code;\r\n                oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\r\n            } else {\r\n                let oauthErrorMsg\r\n                if (qp.error) {\r\n                    oauthErrorMsg = \"[\"+qp.error+\"]: \" +\r\n                        (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\r\n                        (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\r\n                }\r\n                oauth2.errCb({\r\n                    authId: oauth2.auth.name,\r\n                    source: \"auth\",\r\n                    level: \"error\",\r\n                    message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\r\n                });\r\n            }\r\n        } else {\r\n            oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\r\n        }\r\n        window.close();\r\n    }\r\n",t:"oauth2-redirect"},"597":{i:0.00304259097347127,u:"../content/capabilities/cms/cms_block/category-block.htm",a:"Category Block  Category Blocks Category blocks are blocks that can be embedded into the category template, for which we can specify on which specific categories we want them to be rendered.\n\t\t For example, we have a Christmas sale that affects the categories  related to toys and sweets. We want to ...",t:"CMS Block Category Connector"},"598":{i:0.00436952211524193,u:"../content/capabilities/cms/cms_page/cms-extension-points.htm",a:" \nThe CMS module provides an extension point for post activation and deactivation of CMS pages. The plugin interface set for this extension point is as follows:\n \nnamespace Spryker\\Zed\\Cms\\Communication\\Plugin;\n\nuse Generated\\Shared\\Transfer\\CmsPageTransfer;\n\ninterface ...",t:"CMS Extension Points   "},"599":{i:0.00765423048812846,u:"../content/capabilities/order_management/refund/refund-2-0.htm",a:" The latest version of this module can be found here  Refund     The Refund module manages the retours refund process. Overview Using  Refund  Extending  Refund  Overview RefundFacade contains the following methods: calculateRefund(array $salesOrderItems, SpySalesOrder $salesOrderEntity) calculates ...",t:"Refund 2.0    "},"600":{i:0.0017817520226361,u:"../content/capabilities/promotions_and_discounts/discount-applying.htm",a:" There are two ways of applying a discount to an order : for cart rule discounts : these discounts are contained in the cart and are calculated automatically for voucher code discounts : these discounts must be added by the customer and they are calculated once they are entered Cart Rule Discounts ...",t:"Applying a Discount    "},"601":{i:0.00191564995252411,u:"../content/capabilities/order_management/url-handling-new-entity.htm",a:"The following information describes how to handle URLs for other types of entities that Spryker core provides. Prerequisites Before you begin, make sure the target entity is already in your database (the one to you would like to assign URLs to). In the examples below we\u0027ll call this entity ...",t:"Handling New Types of Entity URLs"},"602":{i:0.00652071039813223,u:"../content/capabilities/development/collector/collector-types.htm",a:" Data Collection\n\nData aggregation is a complex process of transforming scattered data between different resources, into a new one, usually smaller then the input. There are two basic Collector Types, depending on the way the data is being collected.\n\n AbstractPdoCollector - uses PHP Data Objects ...",t:"Collector Types "},"603":{i:0.00652071039813223,u:"../content/capabilities/development/collector/collector-sched-collector-jobs.htm",a:" The cronjob file jobs.php stores the configuration related to collectors.\n\n \u003c?php\n$jobs[] = [\n    \u0027name\u0027 =\u003e \u0027export-search\u0027,\n    \u0027command\u0027 =\u003e \u0027$PHP_BIN vendor/bin/console collector:search:export\u0027,\n    \u0027schedule\u0027 =\u003e \u0027*/10 * * * *\u0027,\n    \u0027enable\u0027 =\u003e false,\n    \u0027stores\u0027 =\u003e $allStores,\n];\n?\u003e In the ...",t:"Scheduling Collector Jobs "},"604":{i:0.000833836998432783,u:"../content/capabilities/product_management/product_relation/product-relation-building-your-own.htm",a:"To create a new relation type, modify the Yves and Zed applications:\n\n Zed:\n\n Create new relation type in \\Spryker\\Shared\\ProductRelation\\ProductRelationTypes as a new constant type for example TYPE_RELATION_NEW also include to getAvailableRelationTypes returned array. After this you can able select ...",t:"Building Your Own Product Relation Type   "},"605":{i:0.000883235872033857,u:"../content/capabilities/internationalization/glossary/glossary-keys.htm",a:" Glossary keys present two layers of persistence: SQL database storage in-memory key-value storage (Redis) In this section we’ll exemplify the usage of the functionality for managing the glossary keys from the backoffice user interface and the usage of them for the Yves interface through twig ...",t:"Managing Glossary Keys    "},"606":{i:0.00142837837834839,u:"../content/capabilities/order_management/url.htm",a:"The URL module handles dynamic URLs for entities that appear on the front-end (Yves). At the moment, Spryker core provides URL handling for products, CMS pages, categories and URL redirects. The URLs are stored in one database table and each is unique. The database structure for storing URLs looks ...",t:"URL "},"607":{i:0.00937838303176987,u:"../content/capabilities/checkout/checkout-process.htm",a:" Checkout Process In order to use checkout in Yves it should be correctly configured and dependencies should be provided. Each step can have a form, a controller action, the implementation of the step logic and Twig template to render the HTML. Forms - current step form collection. Controller action ...",t:"Checkout Process "},"608":{i:0.00402711338577865,u:"../content/capabilities/order_management/state_machine/state-machine-zed-presentation.htm",a:" To add manual trigger button or history for items, you need to add some implementation. State machine provides methods for triggering events and for retrieving history. StateMachineFacade::processedStateMachine(StateMachineItemTransfer[]) updates the given array of items with data from state ...",t:"Updating Presentation in Zed - State Machine    "},"609":{i:0.00228658643639319,u:"../content/capabilities/promotions_and_discounts/discount-2-0.htm",a:" The latest version of this module can be found here  Discount     The Discount module is responsible of managing discounts in the Spryker OS. The schema below illustrates how discounts are modeled in Zed’s database. Discount Types There are two types of discounts: fixed amount discount ( e.g. 10€ ...",t:"Discount - Version 2.0    "},"610":{i:0.00402711338577865,u:"../content/capabilities/order_management/state_machine/state-machine-implementing-plugin.htm",a:" To start using state machine, you need create a new plugin by implementing the  StateMachineHandlerInterface. This plugin is used when there is need for additional information from client or some action happens and the client needs to be notified about it. List of interface methods that need to be ...",t:"Implementing the Plugin - State Machine    "},"611":{i:0.000721398245816291,u:"../content/industry_partners/hosting/root360.htm",a:"Hosting Provider - Root 360  Partner Information Copyright and Disclaimer See  Disclaimer .   Last review date: Jul. 6th, 2018 ",t:"Hosting Provider - Root 360 "},"612":{i:0.00110829050622814,u:"../content/capabilities/cart/calculation/calculation.htm",a:" Spryker Commerce OS uses the Calculation module to calculate the cart totals that are displayed in the cart/checkout or when the order is placed.\nIt\u0027s also used to recalculate the order totals after refund.\n The calculation module extensively uses plugins to inject calculation algorithms.\n How ...",t:"Calculation    "},"613":{i:0.00129781797988067,u:"../content/front-end_developer_guide/demoshop/twig_templates/twig-best-practices.htm",a:" Include vs Macros vs Embed\n With includes, you can include an entire template. The template has access to any template variables that are currently in scope.\n\n With macros, you are defining a kind of function within Twig that can render a particular component given appropriate objects.\n\n So you ...",t:"Best Practices - Twig Templates "},"614":{i:0.000833836998432783,u:"../content/capabilities/product_management/product_relation/product-relation-types.htm",a:" In Spryker currently there are two types of relations:\n\n Related-products, related products displayed in the product detail page for the currently selected abstract product.\n Up-selling, related products displayed in the cart overview page, related products are from a list of abstract product ids ...",t:"Product Relation Types    "},"615":{i:0.000833836998432783,u:"../content/capabilities/product_management/product_relation/product-relation-yves-datatastore.htm",a:" The product relation collector exports relations to the Yves data store.  This collector is located in the ProductRelationCollector module.\n \nInclude this module in your composer.json file and update. Then add the plugin ProductRelationCollectorPlugin from this module to ...",t:"Yves Datastore Collector - Product Relation    "},"616":{i:0.00082440135013858,u:"../content/capabilities/price/price-types.htm",a:" Price Per Business Unit Offer your customers individual agreements and customize the Prices per Business Unit accordingly. The Spryker Commerce OS allows you to display different prices in your web shop. To avoid unnecessary repetition of values, the data is compressed in the database. You can also ...",t:"Price Types  "},"617":{i:0.00402711338577865,u:"../content/capabilities/order_management/state_machine/state-machine-cronjob.htm",a:" There are three console commands dedicated for the state machine: state-machine:check-condition - checks all the states that have a condition without event and triggers them. state-machine:check-timeout - check timeout expired items and triggers event for them. state-machine:clear-locks - clears ...",t:"Cron Jobs - State Machine    "},"618":{i:0.00235205187755659,u:"../content/capabilities/inventory_management/about-inventory.htm",a:" Inventory is the amount of products you offer to your customers. These products are catalogued and divided into items that are in stock and reserved. The stock value is the physical amount of products you have in your warehouse, whereas availability is an aggregated value per store which reflects ...",t:"Inventory    "},"619":{i:0.00999651025058793,u:"../content/capabilities/development/collector/collector-development.htm",a:" The Collector module provides mechanisms to manage data consumed by front-end application.\n\nTo populate the data stores, 4 steps are required:\n\n Touch\n \nConfigure\n Collect\n Touch\n In order for anything to be synchronized, first it has to be marked (touched) via the Touch mechanism. Each collector ...",t:"Development - Collector "},"620":{i:0.00129781797988067,u:"../content/capabilities/product_management/product_group/product-group-under-the-hood.htm",a:" Database Schema The ProductGroup module provides spy_product_group table that stores product groups. Product group entities have only the id_product_group field, because we don’t need to display or refer to any groups in any way. The only necessary details for a group are the abstract products that ...",t:"Product Group - Under The Hood    "},"621":{i:0.00103230994118844,u:"../content/capabilities/product_management/product_options/product-options-1.htm",a:"   \n            Product options allow to configure a product further. You can define option types and each option type can have 1 to n option values.\n            Each option value has an associated price.\n             Example \n                    You want to sell a piece of artwork as a product ...",t:"Product Options - Version 1    "},"622":{i:0.002121824885072,u:"../content/capabilities/search_and_filter/search_query.htm",a:" Once we have all necessary data in Elasticsearch, it’s time to display them in Yves. In order to achieve this, we first need to query Elasticsearch, which will return raw data for us that we need to  Process Query Result  to display it in our templates. In the SearchClient you can find the search() ...",t:"Search Query  "},"623":{i:0.001276917608879,u:"../content/capabilities/promotions_and_discounts/discount-excl-nonexcl.htm",a:"Exclusive and Non-Exclusive Discounts  Discounts that have the Is_Exclusive flag set with value true cannot be combined. If the cart includes more than one exclusive discount, only the discount that offers the highest discounted value will be applied. If the cart includes a mix of exclusive and ...",t:"Exclusive and Non-exclusive Discounts"},"624":{i:0.000833836998432783,u:"../content/capabilities/product_management/product_relation/product-relation-db-entity-relation.htm",a:" spy_product_relation.fk_product_abstract - is the product for which relation is build.  spy_product_relation.is_active - if relation is not active it will still be exported, but not visible.  spy_product_relation_product_abstract.fk_product_abstract - is the related product.  ...",t:"Database Entity Relation Schema - Product    "},"625":{i:0.00100872082045293,u:"../content/capabilities/master_suite_and_custom_suite/choosing-a-suite.htm",a:" The Sample Suite represents a standard shop, with common functionality and work-flows to show basic features. \nYou can use the Sample Suite as a boilerplate for your own shop and customize it for your products, CI and services.\nCustom Suites are individual versions of the OS that are tailored ...",t:"Choosing the Right Suite for You   "},"626":{i:0.000701521703262348,u:"../content/about_spryker/what_s_new/roadmap.htm",a:"Updated: September 3rd 2018\n We at Spryker are happy to share our plans with you. Our plans are guidelines that give us direction, that moves us forward to continuously evolve and improve our product. However, we are also flexible and we constantly listen and adapt. Therefore, our plans tend to ...",t:"Roadmap"},"627":{i:0.0090290689915111,u:"../content/capabilities/tax/tax-1-0.htm",a:" The Tax module is responsible for handling tax rates that can apply for products, product options or shipment. Overview The tax sets can have different tax rates for each country defined in your shop. You can see in the diagram below how these entities are modeled in the database. A tax set is ...",t:"Tax Version 1.0  "},"628":{i:0.000935103235059846,u:"../content/capabilities/development/code-generator.htm",a:" The CodeGenerator module can generate your project code.  Out of the box it provides generators for Yves, Zed, Client, Service and Shared application layers.\n\n This is a pre-release.\n Installation\n Install it as\n\n composer require --dev spryker/code-generator You need to run vendor/bin/console ...",t:"Code Generator    "},"629":{i:0.00937838303176987,u:"../content/capabilities/checkout/checkout-steps.htm",a:" Entry Step Redirect customer to correct step based on QuoteTransfer state. This step requires input = false so it won’t be rendered. Customer Step The customer step provides three forms (login, register and register as a guest). This step is responsible for filling CustomerTransfer with ...",t:"Checkout Steps   "},"630":{i:0.00402711338577865,u:"../content/capabilities/order_management/state_machine/state-machine-events.htm",a:" There are two main triggers: first one StateMachineFacade::triggerForNewStateMachineItem() is used when first time triggering the state machine for an item; this trigger will initialize the state machine and start transition through states until a decision without event, timeout or manual event is ...",t:"Triggering Events - State Machine    "},"631":{i:0.000751213059647207,u:"../content/administration_interface_guide/products/products.htm",a:"products Delete this text and replace it with your own content.",t:"products"},"632":{i:0.00652071039813223,u:"../content/capabilities/development/collector/collector-running.htm",a:" Each Collector is executed once for each Locale that’s configured in the Store. To see the currently configured locales, check the stores.php configuration file.\n\nThere are three commands which handle collectors related tasks.\n\n console collector:search:export\nconsole ...",t:"Running Collectors "},"633":{i:0.000935103235059846,u:"../content/capabilities/development/architecture-sniffer.htm",a:" We use our  Architecture Sniffer Tool  to assert a certain quality of Spryker architecture for both core and project.\n Running the Tool The sniffer can find a lot of violations and will report them: $ vendor/bin/console code:sniff:architecture\n\n// Sniff a specific subfolder of your project - with ...",t:"Architecture Sniffer Tool"},"634":{i:0.00351223350273345,u:"../content/capabilities/shipment/shipment-overview.htm",a:" The main concepts regarding shipping that are modeled in the database are : shipment carrier shipment method The shipment method is linked to the sales order. The schema below shows how these entities are modeled in the database : A sales order has associated a shipment method. Each shipment method ...",t:"Shipment Overview  "},"635":{i:0.00837733349344734,u:"../content/capabilities/tax/tax-2-0.htm",a:" The latest version of this module can be found here  Tax Version 1.0   Spryker allows to define different tax sets that include one to many different tax rates. Tax Set - Tax Rate Association A tax set has associated at least one tax rate. For products on which there aren’t applied any taxes : ...",t:"Tax Version 2.0   "},"636":{i:0.00142837837834839,u:"../content/capabilities/price/money.htm",a:" Money Handling monetary values can be a problem and is often quite hard. The Money bundle makes it easier to work with monetary values. Spryker handles all monetary values as integer and provides conversions from decimal values to cent values and vice versa. The key feature of this module is to ...",t:"Money  "},"637":{i:0.00190129889419275,u:"../content/capabilities/order_management/state_machine/state-machine-patterns.htm",a:" Process Patterns The State Machine Cook Book describes how to build a state machine with the elements state, transition and event. However there are some recurring design problems that are needed in many processes. In this article common problems and their solution with state machine snippets are ...",t:"State Machine Patterns    "},"638":{i:0.000833836998432783,u:"../content/capabilities/product_management/product_relation/product-relation-query-builder.htm",a:" Query build in Zed allows to select and bulid a dynamic related product query. The query ships with pre-set rules:\n\n sku - filter by abstract product sku.\n name - filter by abstract product name. The locale is Zed’s default locale. If a product matches in that locale it will be related in both ...",t:"Query Builder - Product Relation    "},"639":{i:0.00390464216462256,u:"../content/capabilities/cms/cms_block/cms-block-multistore.htm",a:" Overview The multi-store CMS block feature enables you to manage CMS blocks display per stores through a store toggle element on CMS Block management pages in the Administration Interface. By default CMS Blocks are available in all stores. This feature provides additional configuration when you ...",t:"Multi-store CMS Block   "},"640":{i:0.00406157679146139,u:"../content/capabilities/promotions_and_discounts/discount.htm",a:" Discount The Discount module is responsible for managing discounts in the Spryker OS. Overview In the diagram below you can see how the discount details are stored in the database: The spy_discount_voucher_pool table purpose is to group the vouchers codes generated for each discount. You can ...",t:"Discount    "},"641":{i:0.00330666793568318,u:"../content/capabilities/shipment/shipment-module-overview.htm",a:" The main concepts regarding shipping that are modeled in the database are : shipment carrier shipment method The schema below shows how the sales order and shipment method entities are modeled in the database: A sales order has an associated sales shipment entity which has an associated sales ...",t:"Shipment Module Overview    "},"642":{i:0.00640824200212429,u:"../content/capabilities/cms/cms_page/content-fields-max-size.htm",a:"               By default CMS module doesn\u0027t specify the content field size.\n                Based on your DB (MySql or PostgreSql), it will be transferred to TEXT (65535 bytes) and TEXT (unlimited length) respectively.\n                In case your project requires more, you can redefine field size ...",t:"Defining Maximum Size of Content Fields   "},"643":{i:0.00390464216462256,u:"../content/capabilities/cms/cms_block/product-block.htm",a:"Product Block  Product Blocks Product blocks are blocks that can be embedded in the product template, for which we can specify on which specific product we want them to be rendered.\n\t\t Installation Install the CMS Block Product Connector module with ...",t:"CMS Block Product Connector"},"644":{i:0.000778321482559993,u:"../content/capabilities/product_management/product/product-recommendations.htm",a:"Product Recommendations  With the Product Recommendations feature you can show your customers similar or complementary items while browsing the store.",t:"Product Recommendations   "},"645":{i:0.001276917608879,u:"../content/capabilities/promotions_and_discounts/discount-promotion.htm",a:" \n           For marketing reasons shops sometimes give away free products depending on the cart content. This could be for example when the cart value is high to give away some free perks.\n           Or for example when the customer buys certain product to give away some other product that is ...",t:"Discount Promotion    "},"646":{i:0.001276917608879,u:"../content/capabilities/promotions_and_discounts/discount-ext-module.htm",a:"The main components that describe a discount are: discount collector: Specifies for which items discount is being applied/calculated. Example: The discount can be applied for a specific set of products or for orders that contain a minimum number of items or for orders that have a minimum grand total ...",t:"Extending the Discount Module"},"647":{i:0.000935103235059846,u:"../content/capabilities/development/code-sniffer.htm",a:" To correspond to  PSR-2 standards , we integrated the well known  PHP-CS Fixer  and  PHPCodeSniffer. Code Sniffer is a very powerful tool that helps to keep the code clean and prevent simple mistakes. The sniffer can find all the issues, and can also auto-fix most of them (when used with -f ...",t:"Code Sniffer"},"648":{i:0.000987327394446934,u:"../content/capabilities/checkout/checkout-functionality.htm",a:" Yves Step Processing Checkout in Spryker  demoshop  uses a StepEngine step process to navigate customer step by step through checkout. The checkout process creates a generic approach for step processing; each step knows how to handle the form data, where it has to store data and which conditions ...",t:"Checkout StepEngine   "},"649":{i:0.000883235872033857,u:"../content/capabilities/internationalization/glossary/glossary-how-translations-managed.htm",a:" The key concept for rendering web pages with translated content very fast and with limited resource usage is using a key-value storage. Yves has no connection to Zed’s SQL database and it fetches all dynamic data from a key-value storage(Redis) and a search engine(Elasticsearch). This data contains ...",t:"How Translations are Managed    "},});