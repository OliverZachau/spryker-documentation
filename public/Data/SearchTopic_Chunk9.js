define({"662":{i:0.00644457312350014,u:"../content/capabilities/cms/cms_block/cms-block-multistore.htm",a:" MS Multi-store Overview The multi-store CMS block feature enables you to manage CMS blocks display per stores through a store toggle element on CMS Block management pages in the Administration Interface. By default CMS Blocks are available in all stores. This feature provides additional ...",t:"Multi-store CMS Block "},"663":{i:0.000597105061090627,u:"../content/capabilities/sample_suite_and_custom_suite/choosing-a-suite.htm",a:" The Sample Suite represents a standard shop, with common functionality and work-flows to show basic features. \nYou can use the Sample Suite as a boilerplate for your own shop and customize it for your products, CI and services.\nCustom Suites are individual versions of the OS that are tailored ...",t:"Choosing the Right Suite for You   "},"664":{i:0.00119596781093203,u:"../content/capabilities/cms/cms_block/mg-cms-block-category-connector-console.htm",a:" Click here to expand CMS Block Category Connector Migration script \n\u003c?php\n\n/**\n * Copyright © 2016-present Spryker Systems GmbH. All rights reserved.\n * Use of this software requires acceptance of the Evaluation License Agreement. See LICENSE file.\n */\n\nnamespace ...",t:"Migration Guide - CMS Block Category Connector Migration Console   "},"665":{i:0.00182651756232796,u:"../content/capabilities/search_and_filter/configure-search-features.htm",a:" In this section you’ll learn how to configure faceted navigation, filters, pagination and sorting, so all the important search features that are provided by the Search module. This configuration is only relevant if you enable the three query expanders and result formatters mentioned above. ...",t:"Configure Search Features  "},"666":{i:0.00279337167121119,u:"../content/tutorials/howtos/ht-add-new-shipment-method.htm",a:" \nThis article describes the steps to add a new shipment method, without integrating with the shipment provider.\n In this tutorial we’ll consider the case when you need to add a new shipment method, without the need to integrate it with the shipment providers system.\n \nWhat’s important for this ...",t:"HowTo - Add a New Shipment Method    "},"667":{i:0.00281183727470219,u:"../content/capabilities/development/queue/queue-adapter.htm",a:"Default Queue Adapter  Spryker includes a RabbitMQ adapter package in  spryker/rabbit-mq , if you have already installed the spryker demoshop on your machine, this package will be automatically downloaded for you.\n",t:"Default Queue Adapter "},"668":{i:0.0061029134950594,u:"../content/capabilities/tax/tax-2-0.htm",a:" The latest version of this module can be found here  Tax Version 1.0   Spryker allows to define different tax sets that include one to many different tax rates. Tax Set - Tax Rate Association A tax set has associated at least one tax rate. For products on which there aren’t applied any taxes : ...",t:"Tax Version 2.0   "},"669":{i:0.00374565850004663,u:"../content/capabilities/cms/cms_block/category-block.htm",a:"Category Block  MS Multi-store ,  ML Multi-language Category Blocks Category blocks are blocks that can be embedded into the category template, for which we can specify on which specific categories we want them to be rendered.\n\t\t For example, we have a Christmas sale that affects the categories  ...",t:"CMS Block Category Connector"},"670":{i:0.00393905483320144,u:"../content/capabilities/checkout/checkout-process.htm",a:" Checkout Process In order to use checkout in Yves it should be correctly configured and dependencies should be provided. Each step can have a form, a controller action, the implementation of the step logic and Twig template to render the HTML. Forms - current step form collection. Controller action ...",t:"Checkout Process "},"671":{i:0.00281183727470219,u:"../content/capabilities/development/queue/queue-task.htm",a:" The Queue module provides a specific command for listening to the queues, fetching messages and triggering registered processors, by running this command you will see what messages are going to be consumed and passed to the plugins.\n\n The command syntax is as follows:\n\n ./vendor/bin/console ...",t:"Queue Task "},"672":{i:0.0019369303428516,u:"../content/industry_partners/payment/arvato/v1_0/arvato-risk-check-1-0.htm",a:" \n    Accounted for by external credit agency data and internal existing customer- and order-details\n    the RiskCheck evaluates the probability of payment default for the customer orders.\n \n    The returned decision codes (Result – ActionCode – ResultCode) manage the definition of the eShop’s ...",t:"Arvato 1.0 - Risk Check"},"673":{i:0.000775189310724423,u:"../content/front-end_developer_guide/demoshop/twig_templates/twig-best-practices.htm",a:" Include vs Macros vs Embed\n With includes, you can include an entire template. The template has access to any template variables that are currently in scope.\n\n With macros, you are defining a kind of function within Twig that can render a particular component given appropriate objects.\n\n So you ...",t:"Best Practices - Twig Templates "},"674":{i:0.000590881549031925,u:"../content/capabilities/mailing_and_notifications/mail-how-to-send.htm",a:"The following example represents a real-world scenario: CustomerRegistration. A Customer goes through the registration process in your frontend (Yves) and all customer information is sent to Zed. Zed uses the information to register the customer. Once the registration is completed, the customer will ...",t:"How To Send a Mail"},"675":{i:0.00348019247706179,u:"../content/capabilities/order_management/state_machine/state-machine-implementing-plugin.htm",a:" To start using state machine, you need create a new plugin by implementing the  StateMachineHandlerInterface. This plugin is used when there is need for additional information from client or some action happens and the client needs to be notified about it. List of interface methods that need to be ...",t:"Implementing the Plugin - State Machine    "},"676":{i:0.000757602384698465,u:"../content/capabilities/development/mg-collector.htm",a:" Upgrading from Version 5.* to Version 6.* The general concept of collectors, and collector queries are enhanced to support multi-store. The following classes were altered to support the multi-store concept: AbstractCollector AbstractDatabaseCollector AbstractPdoCollector AbstractPropelCollector ...",t:"Migration Guide - Collector   "},"677":{i:0.00480691546819301,u:"../content/capabilities/cms/cms_block/product-block.htm",a:"Product Block  MS Multi-store ,  ML Multi-language Product Blocks Product blocks are blocks that can be embedded in the product template, for which we can specify on which specific product we want them to be rendered.\n\t\t Installation Install the CMS Block Product Connector module with ...",t:"CMS Block Product Connector"},"678":{i:0.00140766678296624,u:"../content/capabilities/order_management/state_machine/state-machine-zed-presentation.htm",a:" To add manual trigger button or history for items, you need to add some implementation. State machine provides methods for triggering events and for retrieving history. StateMachineFacade::processedStateMachine(StateMachineItemTransfer[]) updates the given array of items with data from state ...",t:"Updating Presentation in Zed - State Machine    "},"679":{i:0.00117751450477212,u:"../content/capabilities/cms/mg-cms.htm",a:" Upgrading from Version 4.* to Version 5.* CMS version 5.0 is responsible only for CMS pages and page versioning. CMS Block functionality became more flexible and moved to  CmsBlock module . If you used CMS Blocks before, you need to migrate your data to the new structure.\n    If you did not use CMS ...",t:"Migration Guide - CMS"},"680":{i:0.000775189310724423,u:"../content/capabilities/product_management/product_group/product-group-under-the-hood.htm",a:" Database Schema The ProductGroup module provides spy_product_group table that stores product groups. Product group entities have only the id_product_group field, because we don’t need to display or refer to any groups in any way. The only necessary details for a group are the abstract products that ...",t:"Product Group - Under The Hood    "},"681":{i:0.000444602461691425,u:"../content/capabilities/development/logger.htm",a:" Spryker contains a  PSR-3  compatible logger which can be customized to any needs. You can use the logger everywhere in the system, as in the example below: \u003c?php\n\nuse Spryker\\Shared\\Log\\LoggerTrait;\n\nclass MyClass\n{\n\n    use LoggerTrait;\n\n    public function myFunction()\n    {\n        // This will ...",t:"Logger    "},"682":{i:0.00109262476324355,u:"../content/capabilities/promotions_and_discounts/discount-applying.htm",a:" There are two ways of applying a discount to an order : for cart rule discounts : these discounts are contained in the cart and are calculated automatically for voucher code discounts : these discounts must be added by the customer and they are calculated once they are entered Cart Rule Discounts ...",t:"Applying a Discount    "},"683":{i:0.000775117524782963,u:"../content/capabilities/checkout/checkout-functionality.htm",a:" Yves Step Processing Checkout in Spryker  demoshop  uses a StepEngine step process to navigate customer step by step through checkout. The checkout process creates a generic approach for step processing; each step knows how to handle the form data, where it has to store data and which conditions ...",t:"Checkout StepEngine "},"684":{i:0.000573168914203293,u:"../content/capabilities/payment/how_to_implement_invoice_payment/ht-implement-invoice-payment.htm",a:" Invoice Payment This article describes the steps that you need to consider when you need to implement invoice payment method without integrating with a third party payment service provider.\n In this HowTo, we will add a new module called PaymentMethods.\n\n If this is you first time creating a new ...",t:"HowTo - Implement Invoice Payment   "},"685":{i:0.000662790391974016,u:"../content/capabilities/payment/how_to_implement_invoice_payment/ht-invoice-payment-fe-be-shared.htm",a:" As you can see, we need to identify the new payment type through some unique constants which we’re going to define under the Shared namespace, since they’re needed both by Yves and Zed.\n\n Create the PaymentMethodsConstants interface in the Shared namespace, where you’ll define these constants.\n\n ...",t:"HowTo - Implement Invoice Payment - Shared Implementation   "},"686":{i:0.00118335506450888,u:"../content/capabilities/product_management/mg-product-option-cart-connector.htm",a:"Upgrading from Version 4.* to Version 5.* Update spryker/product-option to at least version 6.0.0. You can find additional information to product option module upgrade:  here . Install/Update spryker/price to at least version 5.0.0.  Update spryker/product-option-cart-connector to version 5.0.0. \n   ...",t:"Migration Guide - Product Option Cart Connector"},"687":{i:0.000783046189191264,u:"../content/capabilities/promotions_and_discounts/discount-excl-nonexcl.htm",a:"Exclusive and Non-Exclusive Discounts  Discounts that have the Is_Exclusive flag set with value true cannot be combined. If the cart includes more than one exclusive discount, only the discount that offers the highest discounted value will be applied. If the cart includes a mix of exclusive and ...",t:"Exclusive and Non-exclusive Discounts"},"688":{i:0.000674827183173003,u:"../content/capabilities/search_and_filter/search-multi-currency.htm",a:" MC Multi-currency \n            If you don\u0027t have the multi-currency feature in you current project yet and want to migrate, you have to follow certain steps to migrate your system.\n\n            First  migrate Price  and  modules related to multi-currency  before proceeding with the search for ...",t:"Multi-Currency - Search  "},"689":{i:0.00063695848945505,u:"../content/capabilities/crm/user-rights-management.htm",a:" User and rights management is a general term that describes the security functionality for controlling user access to perform various roles throughout the system. In the Spryker Commerce OS user and rights management is implemented in the following three bundles: ACL - ACL stands for Access Control ...",t:"User and Rights Management "},"690":{i:0.00360660899186755,u:"../content/capabilities/order_management/state_machine/state-machine-cronjob.htm",a:" There are three console commands dedicated for the state machine: state-machine:check-condition - checks all the states that have a condition without event and triggers them. state-machine:check-timeout - check timeout expired items and triggers event for them. state-machine:clear-locks - clears ...",t:"Cron Jobs - State Machine    "},"691":{i:0.00281183727470219,u:"../content/capabilities/development/queue/queue-benefits.htm",a:" The following is a list of the Queus System’s benefits:\n \nAsynchronous: Message processing can be offloaded to different times to prevent bottlenecks and run when necessary.\n Decoupling: The queue provides separate layers for data and processing\n Scalability: Adding more processes for receiving and ...",t:"Queue Benefits "},"692":{i:0.000498225196983234,u:"../content/capabilities/product_management/product_relation/product-relation-query-builder.htm",a:" Query build in Zed allows to select and bulid a dynamic related product query. The query ships with pre-set rules:\n\n sku - filter by abstract product sku.\n name - filter by abstract product name. The locale is Zed’s default locale. If a product matches in that locale it will be related in both ...",t:"Query Builder - Product Relation    "},"693":{i:0.000444602461691425,u:"../content/capabilities/development/installer.htm",a:" ML Multi-language ,  MS Multi-store ,  MC Multi-currency The Installer module is responsible of managing the installment process of required database data  in any environment. Plugin Stack You define the installer plugins of the bundles you want to include in the Pyz ImporterDependencyProvider: ...",t:"Installer    "},"694":{i:0.000516459768375086,u:"../content/capabilities/payment/how_to_implement_direct_debit/dd-checkout-implementation.htm",a:" The next step is to integrate direct debit into Checkout. In the PaymentMethods/Dependency/Injector from Yves add the CheckoutDependencyInjector, that will inject the direct debit form and handler into the Checkout module: Click to expand the code sample \u003c?php\n\nnamespace ...",t:"Integrate Direct Debit into Checkout    "},"695":{i:0.000573168914203293,u:"../content/capabilities/payment/how_to_implement_direct_debit/ht-implement-dd.htm",a:" This article describes the steps how to implement direct debit payment method without integrating with a third party payment service provider.\n For this example, we will add a new module called PaymentMethods.\n\n If it is your the first time creating a new module, check out the  tutorial on creating ...",t:"HowTo - Implement Direct Debit Payment   "},"696":{i:0.000854896167453268,u:"../content/capabilities/order_management/url.htm",a:"The URL module handles dynamic URLs for entities that appear on the front-end (Yves). At the moment, Spryker core provides URL handling for products, CMS pages, categories and URL redirects. The URLs are stored in one database table and each is unique. The database structure for storing URLs looks ...",t:"URL   "},"697":{i:0.0028346489302217,u:"../content/capabilities/development/queue/queue.htm",a:" Concepts Sender\t -  a program that sends messages.\n Receiver\t- a program that waits to receive messages.\n Message - \ta string or binary data  passed from Sender to Receiver.\n Message Box\t- Similar to a Mailbox, here you can store, send and receive messages.\n Introduction\n The Queue module provides ...",t:"Queue "},"698":{i:0.00291304666702337,u:"../content/capabilities/development/flysystem.htm",a:" The Flysystem module integrates Spryker with the  thephpleague/flysystem  vendor package. It handles operations, flysystem adapter configuration and provides a FlysystemFilesystemBuilderPluginInterface, where the build() method is expected to return a concrete implementation of the ...",t:"Flysystem    "},"699":{i:0.00281183727470219,u:"../content/capabilities/development/queue/queue-workers.htm",a:"Queue Worker is another useful command that sends the Task to a background process and provides parallel processing. By adjusting the Worker config we can run tasks with different time slot and a different amount of processes.\n Command syntax:\n\n ./vendor/bin/console queue:worker:start -vvv\n",t:"Queue Workers"},"700":{i:0.000444602461691425,u:"../content/capabilities/development/zed_api/zed-api.htm",a:" The Spryker OS offers a flexible REST API for Zed. It maps basic REST functionality to the persistence layer of the Spryker backend.\n\n By default, the API accepts and returns JSON as format. But it can be extended to work with any format. As for JSON, the API specification is close to JSON API ...",t:"Zed API (BETA)    "},"701":{i:0.00199554174987093,u:"../content/capabilities/search_and_filter/search-4-0.htm",a:" The latest version of this module can be found in  Search      section One of the most important features in an e-commerce application is to give the customer the ability to find the specific products. Depending on how easy it is to find the products the customer is searching for and how relevant ...",t:"Search 4.0"},"702":{i:0.0018935370351376,u:"../content/capabilities/cms/cms_block/mg-cms-block.htm",a:"Migration Guide - CMS Block  Upgrading from Version 1.* to Version 2.* This version allows to save CMS Block-Store relation. Update spryker/cms-block module to at least Version 2.0.0. \n                Update your spryker/cms-block-collector module to at least Version 2.0.0.\n                You can ...",t:"Migration Guide - CMS Collector"},"703":{i:0.00191760444547328,u:"../content/capabilities/internationalization/currency.htm",a:" \nThe Currency module provides an easy way to retrieve information about a currency given as an ISO code.\n The methods in the CurrencyFacade will always return an instance of the CurrencyTransfer. You can get any currency by its ISO code or the current configured currency.\n\n Usage\n CurrencyFacade ...",t:"Currency    "},"704":{i:0.000444602461691425,u:"../content/capabilities/development/architecture-sniffer.htm",a:" We use our  Architecture Sniffer Tool  to assert a certain quality of Spryker architecture for both core and project.\n Running the Tool The sniffer can find a lot of violations and will report them: $ vendor/bin/console code:sniff:architecture\n\n// Sniff a specific subfolder of your project - with ...",t:"Architecture Sniffer Tool"},"705":{i:0.000444602461691425,u:"../content/capabilities/development/zed-request.htm",a:" This module is used to handle requests from Yves to Zed and the responses from Zed. Internally it makes use of the well known  Guzzle  library. HandlerStackContainer Guzzle provides a way to add a so called middleware. It makes use of a handler stack where you can push a middleware to. For more ...",t:"Zed Request  "},"706":{i:0.00524044877003349,u:"../content/capabilities/order_management/sales/sales-5-0.htm",a:" The latest version of this module can be found here  Sales     Getting Totals for Order Spryker does not store order grand total or subtotal amounts; all amounts are stored before calculation, order items store single item gross amounts, discounts store single item discount amount. To get the ...",t:"Sales 5.0    "},"707":{i:0.000783046189191264,u:"../content/capabilities/promotions_and_discounts/discount-promotion.htm",a:" \n           For marketing reasons shops sometimes give away free products depending on the cart content. This could be for example when the cart value is high to give away some free perks.\n           Or for example when the customer buys certain product to give away some other product that is ...",t:"Discount Promotion    "},"708":{i:0.000516459768375086,u:"../content/capabilities/payment/how_to_implement_invoice_payment/ht-invoice-payment-test.htm",a:"HowTo - Implement Invoice Payment - Test  When you have completed the instructions on  front end ,  back end  and  shared  implementation, you are able to test the payment method you just implemented.\n\nSubmit a new order from Yves. After that you can control the flow of the order in Zed UI.",t:"HowTo - Implement Invoice Payment - Test   "},"709":{i:0.00389685384523909,u:"../content/capabilities/development/collector/collector-sched-collector-jobs.htm",a:" The cronjob file jobs.php stores the configuration related to collectors.\n\n \u003c?php\n$jobs[] = [\n    \u0027name\u0027 =\u003e \u0027export-search\u0027,\n    \u0027command\u0027 =\u003e \u0027$PHP_BIN vendor/bin/console collector:search:export\u0027,\n    \u0027schedule\u0027 =\u003e \u0027*/10 * * * *\u0027,\n    \u0027enable\u0027 =\u003e false,\n    \u0027stores\u0027 =\u003e $allStores,\n];\n?\u003e In the ...",t:"Scheduling Collector Jobs "},"710":{i:0.000617031775272839,u:"../content/capabilities/product_management/product_options/product-options-1.htm",a:" ML Multi-language ,  MS Multi-store ,  MC Multi-currency   \n            Product options allow to configure a product further. You can define option types and each option type can have 1 to n option values.\n            Each option value has an associated price.\n             Example \n                 ...",t:"Product Options - Version 1    "},"711":{i:0.00281183727470219,u:"../content/capabilities/development/queue/queue-job-config.htm",a:" You can also find the Worker configuration in jobs.php as part of the Demopshop  and adjust the worker command to run every minute.\n\n To adjust the worker command to run every minute:\n \u003c?php\n\n$jobs[] = [\n    \u0027name\u0027 =\u003e \u0027queue-worker-start\u0027,\n    \u0027command\u0027 =\u003e \u0027$PHP_BIN vendor/bin/console ...",t:"Queue Job Configuration "},"712":{i:0.00597478802191877,u:"../content/capabilities/development/collector/collector-development.htm",a:" The Collector module provides mechanisms to manage data consumed by front-end application.\n\nTo populate the data stores, 4 steps are required:\n\n Touch\n \nConfigure\n Collect\n Touch\n In order for anything to be synchronized, first it has to be marked (touched) via the Touch mechanism. Each collector ...",t:"Development - Collector "},"713":{i:0.0015578192359315,u:"../content/industry_partners/payment/arvato/v1_0/arvato-1-0.htm",a:" The purpose of developing the risk solution services is to provide a complete and comprehensive risk management\n    for the eCommerce/mail-order industry, contributing to a high level of modularization and automation. Besides the use\n    of pre-configured service modules for risk management, risk ...",t:"Risk Solution Services Integration - Arvato 1.0   "},"714":{i:0.00899891195822163,u:"../content/capabilities/payment/refund/refund.htm",a:" Refund Refund manages the retour refund process. Overview RefundFacade contains the following methods: calculateRefund(array $salesOrderItems, SpySalesOrder $salesOrderEntity) calculates refundable amount for the sales order saveRefund(RefundTransfer $refundTransfer) persists the calculated refund ...",t:"Refund    "},"715":{i:0.0030287679369637,u:"../content/capabilities/cms/cms_widget/cms-widget.htm",a:" With CMS content widgets we are bringing more power to CMS pages and blocks. You can easily include placeholders to display products, product groups and products sets in CMS pages and blocks. Multiple templates allow you to define which template is used per widget. So, you can for example apply ...",t:"CMS Widget "},"716":{i:0.000606565813882837,u:"../content/capabilities/master_suite_and_custom_suite/choosing-a-suite.htm",a:" The Sample Suite represents a standard shop, with common functionality and work-flows to show basic features. \nYou can use the Sample Suite as a boilerplate for your own shop and customize it for your products, CI and services.\nCustom Suites are individual versions of the OS that are tailored ...",t:"Choosing the Right Suite for You   "},"717":{i:0.000957064435794106,u:"../content/capabilities/cart/cart-functionality.htm",a:" Our Cart consists of a few components in Yves and Zed. The Yves components  create the cart requests and persist the cart into the session. The Zed components  persist the data into the database and expand the items with data obtained from plugins. Cart operations are invoked in CartClient, which ...",t:"Cart Functionality "},"718":{i:0.000516459768375086,u:"../content/capabilities/payment/how_to_implement_direct_debit/dd-test-implementation.htm",a:"Testing the Direct Debit Implementation  Now you are able to test the payment method you just implemented.\n\nSubmit a new order from Yves. After that you can control the flow of the order in Zed UI.",t:"Testing the Direct Debit Implementation   "},"719":{i:0.000606565813882837,u:"../content/capabilities/checkout/payment-shipment-methods.htm",a:"ML Multi-language ,  MC Multi-currency The Spryker Commerce OS offers integrations with several payment and shipment providers that can be offered to the customers during the checkout process.\nThe selection of shipment methods can be arranged by carrier and availability. Payment methods can easily ...",t:"Payment and Shipment Methods"},"720":{i:0.0066848594719983,u:"../content/capabilities/tax/tax-1-0.htm",a:" The Tax module is responsible for handling tax rates that can apply for products, product options or shipment. Overview The tax sets can have different tax rates for each country defined in your shop. You can see in the diagram below how these entities are modeled in the database. A tax set is ...",t:"Tax Version 1.0  "},"721":{i:0.000494603404718611,u:"../content/capabilities/development/zed_api/zed-api-crud-function.htm",a:" Filtering\n For find action we return a paginated collection that can be limited and customized based on query string input or headers. So using the provided FilterPreProcessors one can enable filtering (conditions), sorting (and multi-sorting) and pagination.\n\n Condition Filtering\n For the ...",t:"CRUD Functionality - Zed API    "},"722":{i:0.00270983699732366,u:"../content/capabilities/search_and_filter/search_query.htm",a:" Once we have all necessary data in Elasticsearch, it’s time to display them in Yves. In order to achieve this, we first need to query Elasticsearch, which will return raw data for us that we need to  Process Query Result  to display it in our templates. In the SearchClient you can find the search() ...",t:"Search Query  "},"723":{i:0.000444602461691425,u:"../content/capabilities/development/modules.htm",a:" A module is a group of files (PHP classes, test classes, configuration files, CSS files, etc) that refer to one concept and it’s written in a way that it makes it usable by other modules. Modules can be logically divided into categories where some are mandatory and necessary for running the OS and ...",t:"Module Guide    "},"724":{i:0.000650242965576524,u:"../content/capabilities/payment/dummy-payment.htm",a:" Do not use this code for production but you can use it as a starting point for new payment integrations. What is the DummyPayment for: it brings a simple state machine it shows how to integrate payment into the system it shows how to handle refunds it allows to test checkout process in several ways ...",t:"Dummy Payment    "},"725":{i:0.0018671329380093,u:"../content/capabilities/product_management/mg-product-option.htm",a:"Upgrading from Version 5.* to Version 6.* Update spryker/product-option to at least version 6.0.0. Install/Update spryker/currency to at least version 3.0.0. You can find additional information to currency module upgrade:  here . Install/Update spryker/price to at least version 5.0.0. Update ...",t:"Migration Guide - Product Option"},"726":{i:0.00104752880470347,u:"../content/capabilities/cms/mg-cms-collector.htm",a:" Upgrading from Version 1.* to Version 2.* Upgrade spryker/cms module to at least 6.2 version. Check out the  CMS migration guide  for additional help. Upgrade spryker/cms-content-widget module to at least 1.1 version if you use CmsPageCollectorParameterMapExpanderPlugin plugin. CMS page data ...",t:"Migration Guide - CMS Collector"},"727":{i:0.000444602461691425,u:"../content/capabilities/development/code-sniffer.htm",a:" To correspond to  PSR-2 standards , we integrated the well known  PHP-CS Fixer  and  PHPCodeSniffer. Code Sniffer is a very powerful tool that helps to keep the code clean and prevent simple mistakes. The sniffer can find all the issues, and can also auto-fix most of them (when used with -f ...",t:"Code Sniffer"},"728":{i:0.00135149091543557,u:"../content/capabilities/cart/calculation/mg-calculation.htm",a:" Upgrading from Version 3.* to Version 4.* To upgrade from 3* to 4*, composer update your calculator to version 4. Updating Calculator Stacks In the new version there are two new calculator stacks, getQuoteCalculatorPluginStack and getOrderCalculatorPluginStack. They are both defined in ...",t:"Migration Guide - Calculation    "},"729":{i:0.000516459768375086,u:"../content/capabilities/payment/how_to_implement_prepayment/ht-prepayment-test.htm",a:"HowTo - Test Prepayment Implementation  Now you are able to test the payment method you just implemented.\n\nSubmit a new order from Yves. After that you can control the flow of the order in Zed UI.\n\n",t:"HowTo - Test Prepayment Implementation   "},});