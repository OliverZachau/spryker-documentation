<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" class="_Skins_HTML5___Top_Navigation" data-mc-search-type="Stem" data-mc-help-system-file-name="Default.xml" data-mc-path-to-help-system="../../../" data-mc-has-content-body="True" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic;Default" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="About Spryker|Understanding Spryker">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="author" content="" /><title>Spryker Architecture Concepts</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../Skins/Fluid/Stylesheets/MadCapSearch.Google.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" />
        <link href="../../../Skins/Fluid/stylesheets/foundation.6.2.3.css" rel="stylesheet" />
        <link href="../../../Skins/Fluid/stylesheets/styles.css" rel="stylesheet" />
        <link href="../../../Skins/Fluid/stylesheets/tablet.css" rel="stylesheet" />
        <link href="../../../Skins/Fluid/stylesheets/mobile.css" rel="stylesheet" />
        <link href="../../resources/stylesheets/prism.css" rel="stylesheet" />
        <style>/*&lt;meta /&gt;*/

.button.topic-ratings-button
{
	-pie-background: transparent url('../../../Skins/Default/Stylesheets/Images/star-full.png') no-repeat center center;
}

.button.separator-button
{
	-pie-background: linear-gradient(#ffffff, #ececec);
}

.button.edit-user-profile-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/edit-profile.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.button.print-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/printer.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.button.expand-all-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/expand.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.button.collapse-all-button
{
	-pie-background: url('../../../Skins/Default/Stylesheets/Images/collapse.png') no-repeat center center, linear-gradient(#ffffff, #ececec);
}

.needs-pie
{
	behavior: url('../../../Resources/Scripts/PIE-no-motw.htc');
}

</style>
        <link href="../../resources/stylesheets/mainstyles.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.6.2.3_custom.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapSearch.Google.js">
        </script>
    </head>
    <body>
        <div class="foundation-wrap off-canvas-wrapper">
            <div class="off-canvas-wrapper-inner" data-off-canvas-wrapper="">
                <aside class="off-canvas position-right" id="offCanvas" data-off-canvas="" data-position="right" data-mc-ignore="true">
                    <ul class="off-canvas-drilldown vertical menu off-canvas-list" data-drilldown="" data-mc-back-link="Back" data-mc-css-tree-node-expanded="is-drilldown-submenu-parent" data-mc-css-tree-node-collapsed="is-drilldown-submenu-parent" data-mc-css-sub-menu="vertical menu slide-in-right is-drilldown-submenu" data-mc-include-indicator="False" data-mc-include-icon="False" data-mc-include-parent-link="True" data-mc-include-back="True" data-mc-defer-expand-event="True" data-mc-expand-event="click.zf.drilldown" data-mc-toc="True">
                    </ul>
                </aside>
                <div class="off-canvas-content inner-wrap" data-off-canvas-content="">
                    <div data-sticky-container="" class="title-bar-container">
                        <nav class="title-bar tab-bar sticky" data-sticky="" data-options="marginTop:0" style="width:100%" data-sticky-on="small" data-mc-ignore="true">
                            <div class="middle title-bar-section outer-row clearfix">
                                <div class="menu-icon-container relative clearfix">
                                    <button class="menu-icon" data-toggle="offCanvas"><span></span>
                                    </button>
                                </div>
                            </div>
                            <div class="title-bar-layout outer-row">
                                <div class="logo-wrapper"><a class="logo" href="../../home.htm" alt="Logo"></a>
                                </div>
                                <div class="navigation-wrapper nocontent">
                                    <ul class="navigation clearfix" data-mc-css-tree-node-has-children="has-children" data-mc-css-sub-menu="sub-menu" data-mc-expand-event="mouseenter" data-mc-top-nav-menu="True" data-mc-max-depth="3" data-mc-include-icon="False" data-mc-include-indicator="False" data-mc-include-children="True" data-mc-include-siblings="True" data-mc-include-parent="True" data-mc-toc="True">
                                        <li class="placeholder" style="visibility:hidden"><a>placeholder</a>
                                        </li>
                                    </ul>
                                </div>
                                <div class="nav-search-wrapper">
                                    <div class="nav-search row">
                                        <form>
                                            <div id="yZvMnnHOy0Gzc1X9vI4_YQ" class="search-bar search-bar-container needs-pie">
                                            </div>
                                        </form>
                                    </div>
                                </div>
                            </div>
                        </nav>
                    </div>
                    <section class="main-section">
                        <div class="row outer-row sidenav-layout">
                            <div class="sidenav-wrapper">
                                <div class="sidenav-container">
                                    <ul class="off-canvas-accordion vertical menu sidenav" data-accordion-menu="" data-mc-css-tree-node-expanded="is-accordion-submenu-parent" data-mc-css-tree-node-collapsed="is-accordion-submenu-parent" data-mc-css-sub-menu="vertical menu accordion-menu is-accordion-submenu nested" data-mc-include-indicator="False" data-mc-include-icon="False" data-mc-include-parent-link="False" data-mc-include-back="False" data-mc-defer-expand-event="True" data-mc-expand-event="click.zf.accordionMenu" data-mc-toc="True" data-mc-side-nav-menu="True">
                                    </ul>
                                </div>
                            </div>
                            <div class="body-container" data-mc-content-body="True">
                                <script src="../../resources/prism.js">
                                </script>
                                <div class="search-container">
                                    <form>
                                        <div id="XW-a8l3eEEm5Bdudr8vRpg" class="search-bar search-bar-container needs-pie _Skins_SearchTopics mc-component">
                                        </div>
                                    </form>
                                </div>
                                <div class="row collapse">
                                    <div class="top-bar">
                                        <div class="nocontent">
                                            <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="3" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">You are here: </span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="topic-layout">
                                        <div>
                                            <div class="side-menu">
                                                <div data-sticky-container="" id="vLiV7gl_H0KZXMZy93l_Pw">
                                                    <div class="sticky sticky-menu" style="width:100%" data-sticky="" data-top-anchor="vLiV7gl_H0KZXMZy93l_Pw:top" data-bottom-anchor="contentBody:bottom" data-sticky-on="small" data-scroll-container-on="small">
                                                        <ul class="nocontent menu _Skins_SideMenu mc-component" data-mc-is-context-sensitive="True" data-mc-linked-toc="Data/Tocs/master.js" data-mc-side-menu="True" data-mc-max-depth="1" data-mc-include-icon="False" data-mc-include-indicator="False" data-mc-include-children="True" data-mc-include-siblings="True" data-mc-include-parent="True" data-mc-toc="True">
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div>
                                            <div class="side-menu">
                                                <div class="buttons popup-container clearfix topicToolbarProxy _Skins_TopicToolbar mc-component nocontent" style="mc-topic-toolbar-items: ;">
                                                    <div class="button-group-container-left">
                                                        <div class="button-group star-buttons loading feedback-topic-required">
                                                            <div class="button star-button topic-ratings-empty-button" data-state1-class="topic-ratings-empty-button" data-state2-class="topic-ratings-button" title="Click a star to rate this topic" data-state1-title="Click a star to rate this topic" data-state2-title="Click a star to rate this topic">
                                                                <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="topic rating" />
                                                            </div>
                                                            <div class="button star-button topic-ratings-empty-button" data-state1-class="topic-ratings-empty-button" data-state2-class="topic-ratings-button" title="Click a star to rate this topic" data-state1-title="Click a star to rate this topic" data-state2-title="Click a star to rate this topic">
                                                                <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="topic rating" />
                                                            </div>
                                                            <div class="button star-button topic-ratings-empty-button" data-state1-class="topic-ratings-empty-button" data-state2-class="topic-ratings-button" title="Click a star to rate this topic" data-state1-title="Click a star to rate this topic" data-state2-title="Click a star to rate this topic">
                                                                <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="topic rating" />
                                                            </div>
                                                            <div class="button star-button topic-ratings-empty-button" data-state1-class="topic-ratings-empty-button" data-state2-class="topic-ratings-button" title="Click a star to rate this topic" data-state1-title="Click a star to rate this topic" data-state2-title="Click a star to rate this topic">
                                                                <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="topic rating" />
                                                            </div>
                                                            <div class="button star-button topic-ratings-empty-button" data-state1-class="topic-ratings-empty-button" data-state2-class="topic-ratings-button" title="Click a star to rate this topic" data-state1-title="Click a star to rate this topic" data-state2-title="Click a star to rate this topic">
                                                                <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="topic rating" />
                                                            </div>
                                                        </div>
                                                        <div class="button-separator feedback-topic-required">
                                                        </div>
                                                        <button class="button feedback-required login-button" id="normalLoginBtn" data-state1-class="login-button" data-state2-class="edit-user-profile-button" title="Login" data-state1-title="Login">
                                                            <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="login" />
                                                        </button>
                                                        <button class="button needs-pie print-button" title="Print">
                                                            <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="print" />
                                                        </button>
                                                        <button class="button needs-pie expand-all-button" data-state1-class="expand-all-button" data-state2-class="collapse-all-button" data-state2-title="Collapse all" title="Expand all" data-state1-title="Expand all">
                                                            <img src="../../../Skins/Default/Stylesheets/Images/transparent.gif" alt="expand all" />
                                                        </button>
                                                    </div>
                                                </div>
                                                <h1>Spryker Architecture Concepts</h1>
                                                <h2><span style="color: #e35d44;font-weight: bold;">Commerce OS &amp; Front-end Apps</span>
                                                </h2>
                                                <p>User front-ends are not anymore the same as we used to have 10 years ago. We used to have our desktop displays as the main front-end for different applications, so applications were designed for that desktop display only. In the last few years, many new different front-ends have been evolving rapidly from native apps on smartphones, tablets, and smartwatches to online bots and voice assistants. All of these mediums are recently being used in different e-commerce applications. Spryker’s unique architecture enables all of these front-ends no matter what the technology behind them is.</p>
                                                <h3><b>Why Having Two Applications</b>
                                                </h3>
                                                <p>To allow connecting any front-end application, or several ones at the same time, into the Spryker Commerce OS, Spryker architecture is designed with two main application layers: front-end and back-end.</p>
                                                <p>Spryker is shipped with a default front-end application working as a web app called Shop App. Along with this app, you can have any other front-end app you need for your business: a native app, Alexa Skill, an e-commerce bot, a dash button, or an IoT device.</p>
                                                <p>Not just that, having front-end and back-end applications brings 3 main other benefits:</p>
                                                <ol>
                                                    <li value="1"><b>Performance</b>: a front-end application in Spryker uses a data storage separated from the back-end one. It uses a blazing fast key-value storage while the back-end uses a relational database. With this separation, it is way faster than using the traditional way of sharing one relational database for both applications.</li>
                                                    <li value="2"><b>Scalability</b>: as front-ends in Spryker have their own applications, storages, and deployments, scalability becomes easily achievable and given by the architecture. Spryker can be easily scaled out horizontally by simply just adding more instances with more storages without affecting the back-end application and logic.</li>
                                                    <li value="3"><b>Security</b>: having two applications, accessing the back-end relational database becomes a harder challenge for cyber attacks. The back-end application also is usually hidden behind a firewall making the Commerce OS even more secured for different e-commerce applications.</li>
                                                </ol>
                                                <h3><b>Data Separation: Database &amp; Storage</b>
                                                </h3>
                                                <p>Following the separation between front-end and back-end, one of the main concepts in Spryker is the separation of data between the front-end and the Commerce OS. As in any e-commerce shop system, there are always tons of data to persist and usually with relations between different data entities, e.g. orders with products and customers. For managing such data relations, a relational database is needed. The Spryker Commerce OS manages your shop’s data and its relations, thus it comes with a relational database. It uses PostgreSQL as the default database, and also supports MySQL if you prefer using it.</p>
                                                <p>On the other hand, the front-end application only reads static data in order to present to the end customers. The front-end application in Spryker gets all the data pre-aggregated and denormalized so that there is no need for any logic to manage data on the front-end side of the shop. For that, it uses a much faster data storage; a key-value storage. A key-value storage works like a hash-table where retrieval time is so fast compared to the complicated joins and queries in a relational database. For example, to render a product detail page the system needs several pieces of information like the product title, description, attributes, images, and prices. Instead of executing time-consuming queries in the SQL database, all the data is placed in a few entries in the storage and can be loaded by a single lookup.</p>
                                                <p>Spryker uses Redis as the default data storage. It is called, simply: Storage. The reason behind the abstract name is that Spryker allows using any other data storage e.g. MongoDB, Cassandra, or again Postgres for the front-end side. Whatever your preference is, Spryker calls it Storage.</p>
                                                <p>With data separation comes the question: how to sync data between both applications and make sure that the Storage is always up-to-date? Spryker Commerce OS comes with a very fast solution that solves this challenge internally and out-of-the-box. It is called Publish &amp; Sync. Publish &amp; Sync watches the data models and objects in the database and then triggers an update once the data object is modified, added to, or deleted from the database. This triggers an update to the Storage directly and almost instantly, and ensures data is synced between the database and the Storage all the time.</p>
                                                <h3><b>Search</b>
                                                </h3>
                                                <p>Search is an essential part of e-commerce shops. You cannot have a successful shop without having a good search solution. Spryker provides all in-shop search functionalities by utilizing and connecting to search engine technologies.</p>
                                                <p>Spryker uses Elasticsearch by default. Search in Spryker is also simply called Search as you can connect or integrate any other search engine. Search in Spryker follows the same data separation principle. All the relational data is stored in the relational database in the back-end application and published to Elasticsearch when additions, updates, or deletions occur on different data objects. Spryker OS ensures that data is always synced between its back-end and front-end.</p>
                                                <h3><b>Why Separating Storage &amp; Search</b>
                                                </h3>
                                                <p>Now the question comes, how the data is split between Storage and Search? All searchable data related to catalogs, categories, products, CMS pages, and blocks are exported as JSON documents and stored in the search engine (Elasticsearch by default). On the other hand, all static presentational data such as products, navigations, CMS pages and blocks, and translations are stored in the front-end’s Storage (Redis by default).</p>
                                                <p>The reason behind this architecture is that Spryker focuses on the separation of concerns in the used technologies taking into consideration how every technology is meant to be used. After testing, we concluded that using Redis for static representational data boosts the shop performance as retrieving data using the Redis protocol is faster than calling Elasticsearch APIs to retrieve the same data. Thus, Storage and Search are separated.</p>
                                                <p>However, there are some projects where Elasticsearch is used not only as a search engine but also as a storage for data. It depends on the projects’ different preferences on what technologies to use and scale. Following this approach, it is also correct and can work perfectly with the Spryker architecture.</p>
                                                <h3><b>Connecting Front-end with Commerce OS: the Client</b>
                                                </h3>
                                                <p>End customers interact only with the front-end application. The front-end application needs to get data from the Storage, send search requests to the search engine, and send the customer requests to the Commerce OS whenever needed, like adding to the cart, as all the business logic is performed in the Commerce OS.</p>
                                                <p>The Client’s job is to connect the front-end application to all of the surrounding resources needed for the front-end application to work. This includes the Commerce OS, Storage, and Search. It also includes some other resources like Session and Queues.</p>
                                                <p>For each of these resources, there is a Client. So, it is not only one Client, but many of them. Each one of them is responsible for a specific resource or functionality. Spryker, by default, is shipped with the following clients:</p>
                                                <ul>
                                                    <li value="1">SearchClient: to connect to  Elasticsearch using its API.</li>
                                                    <li value="2">StorageClient: to connect to Redis using the Redis protocol; RESP.</li>
                                                    <li value="3">Commerce OS Clients: every functional unit, module as its called in Spryker, has its own client. For example, there are separated clients for cart (CartClient), checkout (CheckoutClient), and customer (CustomerClient). The same applies to all the other modules in Spryker.</li>
                                                </ul>
                                                <p>Commerce OS clients communicate with the Commerce OS using HTTP. They mainly perform <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPCs</a> (remote procedure calls) using HTTP POST requests with a serialized JSON payload. They also do all the necessary authorization and authentication between the two applications.</p>
                                                <h3><b>The Public API</b>
                                                </h3>
                                                <p>Spryker Commerce OS owns its own public API. It connects the front-end application with all the surrounding resources. The main concept behind the public API is to package the Client with a RESTful API, so it can act as the public API for Spryker. As it uses the Client internally, the API allows you to RESTfully access all the resources you need either in the Commerce OS, Storage, or Search.</p>
                                                <h3><b>Session</b>
                                                </h3>
                                                <p>In your e-commerce shop, you, most probably, will need a session to store different kinds of data. Spryker comes with a session implementation that uses Redis by default. The Session uses another instance of Redis though, so the Storage data is separated from the Session. The Session also has its own Client that allows the front-end application to access the Session using the Redis protocol.</p>
                                                <h3><b>Task Scheduling</b>
                                                </h3>
                                                <p>Several operations in the Spryker Commerce OS need schedules, e.g. syncing data between the Commerce OS and the front-end applications, triggering timeout events for the order management system, or any command you add to your shop. To avoid having dependencies to cron jobs and their server deployments, Spryker uses Jenkins for task scheduling.</p>
                                                <h2><span style="color: #e35d44;font-weight: bold;">Modular Commerce OS &amp; Shop Suite</span>
                                                </h2>
                                                <p>Everything built in Spryker is modular. Modular means that every shop functionality is built inside an independent software package. We call these software packages: modules. Every module in Spryker is a single functional unit that is responsible for only one thing. For instance, Spryker has a Checkout module which handles only checkout, and a Cart module that handles only cart functionality. The same applies to all the functionalities and capabilities Spryker has. Every module in that sense has its own name.</p>
                                                <h3><b>Application Layers with Modules</b>
                                                </h3>
                                                <p>Following this modularity and baring in mind having Commerce OS and front-end applications, every module has a Commerce OS and front-end parts. The same thing also applies to the Client and the public API. For example, for the Cart module, you will find that inside the Commerce OS there is a module called Cart. Inside the Shop App, you will also find that there is a module called Cart, or CartPage. And in the Client, there is a module called Cart. It is basically the same module but in different application layers. There are 6 main application layers. A module can be used in all or some of them depending on the functionality the module is responsible for. Every application layer has its name which is also the namespace of the layer. The 6 application layers in Spryker are:</p>
                                                <ol>
                                                    <li value="1"><b>Zed (~Commerce OS)</b>
                                                        <br />The Commerce OS application layer. All the business logic, database operations, and the Backoffice are in this layer. It is basically the back-end application and logic.</li>
                                                    <li value="2"><b>Yves (~Shop App)</b>
                                                        <br />The front-end application layer. All the front-end presentation logic, templates, user experience logic, and interaction are in this layer.</li>
                                                    <li value="3"><b>Public API</b>
                                                        <br />The public API application layer. All the API object definitions and handling are located in this layer.</li>
                                                    <li value="4"><b>Client</b>
                                                        <br />The Client application layer. All the Client logic to connect the front-end application with the surrounding resources is in this layer.</li>
                                                    <li value="5"><b>Shared</b>
                                                        <br />This layer contains all the logic and structures that are shared between the Commerce OS and the front-end application. For instance, data transfer objects and module constants. As both applications should know about the data transfer structures and the constant values to communicate properly, the Shared layer is the place to host them. The same goes for all other shared things between the two applications.</li>
                                                    <li value="6"><b>Service</b>
                                                        <br />This layer acts as a library and contains all the logic that is repetitive between different modules and layers. For example, XML to JSON conversion logic. As this logic is used by different modules and layers, it is better not to repeat the code needed for it. The Service layer is where this logic resides.</li>
                                                </ol>
                                                <h3><b>Inside a Commerce OS Module</b>
                                                </h3>
                                                <p>Let’s dig deeper inside the Commerce OS and see the structure of a module in it. The reason why we are diving deeper inside it is that the Commerce OS is the main application in Spryker and it has a specific architecture concept.</p>
                                                <p>A module in the Commerce OS consists of 4 main software layers. Each layer is responsible for handling one main purpose inside the module.</p>
                                                <ol>
                                                    <li value="1">Persistence Layer<br />This layer is responsible for defining and dealing with the database in a module. The database table schemas and query objects are defined in this layer. The Persistence layer is the lowest layer in the layer hierarchy. This means the Persistence layer cannot access any other layer above it.</li>
                                                    <li value="2">Business Layer<br />This layer is where all the business logic of a module goes to. It is the most important layer of a module as all the actual functionality of the module is implemented here. It usually has several business models to serve the necessary functionality. The Business layer is located directly above the Persistence layer, so it can access it for reading from or writing to the database.</li>
                                                    <li value="3">Communication Layer<br />This layer is the main entry point of a module. When the front-end application communicates with the Commerce OS, the Communication layer is accessed first. Then, the Communication layer directs the request depending on the requested functionality<br />The Communication layer is located directly above the Business layer, so it has access to all the business logic in a module. This is needed so the Communication layer invokes the right business logic when requested. The Communication layer also has read-only access to the Persistence layer in order to get data from the database without the need to pass by the Business layer in case there is no business logic needed in the request.</li>
                                                    <li value="4">Presentation Layer<br />This layer is where the look and feel of the Backoffice are implemented. It only contains the templates of the Backoffice page of a module. The Presentation layer sends requests to the Communication layer in order to get the needed data. Then it shows the data using the templates.</li>
                                                </ol>
                                                <p>Here is a graph that shows the 4 software layers in a Commerce OS module.</p>
                                                <p>
                                                    <img src="../../resources/images/application-layers.png" />
                                                </p>
                                                <p>On the other hand, the front-end architecture is fairly simple. It has routes, controllers, templates, and forms when needed. There are no software layers in the front-end application as there is no need for them and for the additional complexity.</p>
                                                <p>The API, Client, Shared, and Service application layers have simply the logic to handle what is needed from them directly. There is no need for additional software layers as well.</p>
                                                <h2><span style="color: #e35d44;font-weight: bold;">Spryker Software Main Concepts</span>
                                                </h2>
                                                <p>After covering the main architectural concepts of the Spryker’s Commerce OS, front-end, modularity, and the application and software layers, we will dive deeper inside these approaches and explain the main software and coding concepts in Spryker. There are the 7 main software concepts in Spryker.</p>
                                                <ol>
                                                    <li value="1"><b>Facade</b>
                                                    </li>
                                                    <p>Spryker Facades use the <a href="https://en.wikipedia.org/wiki/Facade_pattern" target="_blank">Facade design pattern</a>. They basically hide all the business logic of a module behind them and give a very simple and straightforward interface. Thus, the main API of a module is its Facade. Whenever you want to know what a module does, simply check its Facade interface.</p>
                                                    <p>Spryker’s Facades work as delegators, so they do not have any business logic in them. They simply delegate to the right model in order to handle the needed business logic. There is only one Facade for each module and it is located in the Business layer.</p>
                                                    <li value="2"><b>Factory</b>
                                                    </li>
                                                    <p>Spryker Factories follow the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern" target="_blank">Factory method pattern</a>. They are simply the place where you instantiate objects. This means that in Spryker there are no “new” statements in the codebase outside the Factories. The only exception for that are data objects; data transfer objects and data entities. These two data objects can be instantiated anywhere. All the other objects are instantiated in the Factories. Thus, all object dependencies inside a module are injected in the Factories using Dependency Injection.</p>
                                                    <p>To isolate objects between the software layers in Spryker, every software layer in a module has its own Factory, except the Presentation layer as it does not have objects, only templates. So there are Persistence Factories, Business Factories, and Communication Factories. Glue, Client, and Service application layers have their own Factories as well. Yves can have a Factory when needed, however, it is not enforced by the Spryker architecture as in many cases it is not really needed for the front-end presentation logic.</p>
                                                    <li value="3">
                                                        <p><b>Query Container</b>
                                                        </p>
                                                    </li>
                                                    <p>The Query Container, as the name suggests, is the place where all the database queries of a module exist. The Query Container has ready-built queries to get different data from the database in order to be used by different business logic as needed.</p>
                                                    <p>It is basically the main entry point of the Persistence layer of a module. There is only one Query Container for a module located in the Persistence layer.</p>
                                                    <li value="4">
                                                        <p><b>Client</b>
                                                        </p>
                                                    </li>
                                                    <p>The Client is the place where the implementation of the communication between the front-end application and all the surrounding resources is built. It acts similarly to a Facade where the Client interface shows all the possible functionalities the front-end can invoke. The Client also delegates all the actions to the right resources in order to get the needed responses to the front-end application.</p>
                                                    <p>The Client is not needed for every module, some modules have it and some do not. When there is communication between the front-end and a certain module, this module will then have a Client. There is one Client for each module. Sometimes, there are Clients that connect directly with an external resource. In this case, there is only a Client for this module, no Commerce OS nor front-end parts.</p>
                                                    <li value="5">
                                                        <p><b>Plugin</b>
                                                        </p>
                                                    </li>
                                                    <p>The Plugin in Spryker is a way to extend certain functionality in a module, e.g. the Calculation stack when placing an order. The Calculation module is an abstract idea and should not depend on other modules in order to calculate the final price. Thus, it exposes an interface with the needed method to be implemented by other modules. Now, when there is another module involved in calculating the final price, it simply implements this interface and does the calculation internally in it. This implementation is called Plugin. This plugin along with others can then be injected into the Calculation module. In the end, the Calculation module calculates the final price by running the exposed method from all the injected plugins.</p>
                                                    <p>The idea of the Plugin is used in many different places in Spryker. It is a great way to extend functionality keeping the modularity and dependencies managed properly. A module can implement many different plugins and can have many different plugins injected into it. Plugins are located inside the Communication layer.</p>
                                                    <li value="6">
                                                        <p><b>Dependency Provider</b>
                                                        </p>
                                                    </li>
                                                    <p>With modularity, it happens that different modules need functionalities from other modules. This builds dependencies between these modules, which is okay as long as the dependency makes sense. To provide the necessary functionality, the dependent module gets an object from the other module. As Facades are the main APIs of modules in Spryker, the dependent module gets the Facade of the other module. In some cases, a Client in a module needs another Client from another module. So, the dependent Client gets the Client object from the other module. To manage this kind of module-to-module dependencies, we use the Dependency Provider.</p>
                                                    <p>Dependency Provider is the place where the module-to-module dependencies are defined in a module. Every module has only one Dependency Provider per application layer when needed except the Shared layer. So, a module can have a Dependency Provider in the Commerce OS, another one in the front-end, and another one in Client.</p>
                                                    <p>The main difference between Factories and Dependency Providers is that Factories are responsible for in-module dependencies, while Dependency Providers are responsible for module-to-module dependencies.</p>
                                                    <li value="7">
                                                        <p><b>Transfer Objects</b>
                                                        </p>
                                                    </li>
                                                    <p>To manage data transfer between the front-end and the Commerce OS applications, and between module-to-module communication, we use Data Transfer Objects (DTOs). We call them Transfer Objects. A transfer object in Spryker is simply an object with getters, setters, and some helper functions to make transferring data clear, yet simple to use.</p>
                                                    <p>Transfer Objects are defined as XML files. Every module can define its own Transfer Objects, or ever extend Transfer Objects from other modules when a dependency to that data is needed. These XML files are all merged and then transformed into auto-generated PHP objects.</p>
                                                    <p>Transfer Objects are a great way to represent data contracts between the Commerce OS and the front-end applications. It also represents data contracts between different modules. So, when any data is needed from a module, it is then clear what structure the data has and how to properly use it.</p>
                                                    <p>As both the Commerce OS and the front-end application should know about the structure of the Transfer Objects, the Shared application layer is where the Transfer Objects are located. Every module can have one or more Transfer Objects.</p>
                                                </ol>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section><a data-close="true"></a>
                </div>
            </div>
            <script>/* <![CDATA[ */$(document).foundation();/* ]]> */</script>
        </div>
    </body>
</html>